/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@colyseus/schema/lib/ChangeTree.js":
/*!*********************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/ChangeTree.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChangeTree = /** @class */ (function () {\n    function ChangeTree(parentField, parent, trackAllChanges) {\n        if (parentField === void 0) { parentField = null; }\n        if (trackAllChanges === void 0) { trackAllChanges = false; }\n        this.changed = false;\n        this.changes = [];\n        this.allChanges = [];\n        this.linkedTrees = [];\n        this.parent = parent;\n        this.parentField = parentField;\n        this.trackAllChanges = trackAllChanges;\n    }\n    ChangeTree.prototype.link = function (linkedTree) {\n        this.linkedTrees.push(linkedTree);\n    };\n    ChangeTree.prototype.change = function (field) {\n        this.changed = true;\n        if (this.changes.indexOf(field) === -1) {\n            this.changes.push(field);\n        }\n        if (this.allChanges.indexOf(field) === -1) {\n            this.allChanges.push(field);\n        }\n        if (this.parent) {\n            this.parent.change(this.parentField);\n        }\n    };\n    ChangeTree.prototype.mapIndex = function (instance, key) {\n        if (!this.indexMap) {\n            this.indexMap = new Map();\n            this.indexChange = new Map();\n        }\n        this.indexMap.set(instance, key);\n    };\n    ChangeTree.prototype.getIndex = function (instance) {\n        return this.indexMap && this.indexMap.get(instance);\n    };\n    ChangeTree.prototype.deleteIndex = function (instance) {\n        this.indexMap.delete(instance);\n    };\n    ChangeTree.prototype.mapIndexChange = function (instance, key) {\n        this.indexChange.set(instance, key);\n    };\n    ChangeTree.prototype.getIndexChange = function (instance) {\n        return this.indexChange && this.indexChange.get(instance);\n    };\n    ChangeTree.prototype.deleteIndexChange = function (instance) {\n        this.indexChange.delete(instance);\n    };\n    ChangeTree.prototype.changeAll = function (obj) {\n        var keys = Object.keys(obj);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            this.change(key);\n        }\n    };\n    ChangeTree.prototype.discard = function () {\n        this.changed = false;\n        this.changes = [];\n        if (this.indexChange) {\n            this.indexChange.clear();\n        }\n    };\n    return ChangeTree;\n}());\nexports.ChangeTree = ChangeTree;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/ChangeTree.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/annotations.js":
/*!**********************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/annotations.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar spec_1 = __webpack_require__(/*! ./spec */ \"./node_modules/@colyseus/schema/lib/spec.js\");\nvar encode = __webpack_require__(/*! ./encoding/encode */ \"./node_modules/@colyseus/schema/lib/encoding/encode.js\");\nvar decode = __webpack_require__(/*! ./encoding/decode */ \"./node_modules/@colyseus/schema/lib/encoding/decode.js\");\nvar ChangeTree_1 = __webpack_require__(/*! ./ChangeTree */ \"./node_modules/@colyseus/schema/lib/ChangeTree.js\");\nvar ArraySchema_1 = __webpack_require__(/*! ./types/ArraySchema */ \"./node_modules/@colyseus/schema/lib/types/ArraySchema.js\");\nvar MapSchema_1 = __webpack_require__(/*! ./types/MapSchema */ \"./node_modules/@colyseus/schema/lib/types/MapSchema.js\");\nvar definedSchemas = new Map();\nfunction encodePrimitiveType(type, bytes, value) {\n    var encodeFunc = encode[type];\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction decodePrimitiveType(type, bytes, it) {\n    var decodeFunc = decode[type];\n    if (decodeFunc) {\n        return decodeFunc(bytes, it);\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Schema encoder / decoder\n */\nvar Schema = /** @class */ (function () {\n    // allow inherited classes to have a constructor\n    function Schema() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: { value: new ChangeTree_1.ChangeTree(), enumerable: false, writable: true },\n        });\n        var descriptors = this._descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n    }\n    Object.defineProperty(Schema.prototype, \"_schema\", {\n        get: function () { return this.constructor._schema; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_descriptors\", {\n        get: function () { return this.constructor._descriptors; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_indexes\", {\n        get: function () { return this.constructor._indexes; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"_filters\", {\n        get: function () { return this.constructor._filters; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Schema.prototype, \"$changed\", {\n        get: function () { return this.$changes.changed; },\n        enumerable: true,\n        configurable: true\n    });\n    Schema.prototype.decode = function (bytes, it) {\n        if (it === void 0) { it = { offset: 0 }; }\n        var changes = [];\n        var schema = this._schema;\n        var indexes = this._indexes;\n        var fieldsByIndex = {};\n        Object.keys(indexes).forEach(function (key) {\n            var value = indexes[key];\n            fieldsByIndex[value] = key;\n        });\n        var totalBytes = bytes.length;\n        var _loop_1 = function () {\n            var index = bytes[it.offset++];\n            if (index === spec_1.END_OF_STRUCTURE) {\n                return \"break\";\n            }\n            var field = fieldsByIndex[index];\n            var type_1 = schema[field];\n            var value = void 0;\n            var change = void 0; // for triggering onChange \n            var hasChange = false;\n            if (type_1._schema) {\n                if (decode.nilCheck(bytes, it)) {\n                    it.offset++;\n                    value = null;\n                }\n                else {\n                    value = this_1[\"_\" + field] || new type_1();\n                    value.decode(bytes, it);\n                }\n                hasChange = true;\n            }\n            else if (Array.isArray(type_1)) {\n                type_1 = type_1[0];\n                change = [];\n                var valueRef_1 = this_1[\"_\" + field] || new ArraySchema_1.ArraySchema();\n                value = valueRef_1.clone();\n                var newLength_1 = decode.number(bytes, it);\n                var numChanges = decode.number(bytes, it);\n                hasChange = (numChanges > 0);\n                // FIXME: this may not be reliable. possibly need to encode this variable during\n                // serializagion\n                var hasIndexChange = false;\n                // ensure current array has the same length as encoded one\n                if (value.length > newLength_1) {\n                    value.splice(newLength_1).forEach(function (itemRemoved, i) {\n                        if (itemRemoved.onRemove) {\n                            itemRemoved.onRemove();\n                        }\n                        if (valueRef_1.onRemove) {\n                            valueRef_1.onRemove(itemRemoved, newLength_1 + i);\n                        }\n                    });\n                }\n                for (var i = 0; i < numChanges; i++) {\n                    var newIndex = decode.number(bytes, it);\n                    var indexChangedFrom = void 0; // index change check\n                    if (decode.indexChangeCheck(bytes, it)) {\n                        decode.uint8(bytes, it);\n                        indexChangedFrom = decode.number(bytes, it);\n                        hasIndexChange = true;\n                    }\n                    var isNew = (!hasIndexChange && !value[newIndex]) || (hasIndexChange && indexChangedFrom === undefined);\n                    if (type_1.prototype instanceof Schema) {\n                        var item = void 0;\n                        if (isNew) {\n                            item = new type_1();\n                        }\n                        else if (indexChangedFrom !== undefined) {\n                            item = valueRef_1[indexChangedFrom];\n                        }\n                        else {\n                            item = valueRef_1[newIndex];\n                        }\n                        if (!item) {\n                            item = new type_1();\n                            isNew = true;\n                        }\n                        if (decode.nilCheck(bytes, it)) {\n                            it.offset++;\n                            if (valueRef_1.onRemove) {\n                                valueRef_1.onRemove(item, newIndex);\n                            }\n                            continue;\n                        }\n                        item.decode(bytes, it);\n                        value[newIndex] = item;\n                    }\n                    else {\n                        value[newIndex] = decodePrimitiveType(type_1, bytes, it);\n                    }\n                    if (isNew) {\n                        if (valueRef_1.onAdd) {\n                            valueRef_1.onAdd(value[newIndex], newIndex);\n                        }\n                    }\n                    else if (valueRef_1.onChange) {\n                        valueRef_1.onChange(value[newIndex], newIndex);\n                    }\n                    change.push(value[newIndex]);\n                }\n            }\n            else if (type_1.map) {\n                type_1 = type_1.map;\n                var valueRef = this_1[\"_\" + field] || new MapSchema_1.MapSchema();\n                value = valueRef.clone();\n                var length = decode.number(bytes, it);\n                hasChange = (length > 0);\n                // FIXME: this may not be reliable. possibly need to encode this variable during\n                // serializagion\n                var hasIndexChange = false;\n                var mapKeys = Object.keys(valueRef);\n                for (var i = 0; i < length; i++) {\n                    // `encodeAll` may indicate a higher number of indexes it actually encodes\n                    // TODO: do not encode a higher number than actual encoded entries\n                    if (bytes[it.offset] === undefined ||\n                        bytes[it.offset] === spec_1.END_OF_STRUCTURE) {\n                        break;\n                    }\n                    // index change check\n                    var previousKey = void 0;\n                    if (decode.indexChangeCheck(bytes, it)) {\n                        decode.uint8(bytes, it);\n                        previousKey = mapKeys[decode.number(bytes, it)];\n                        hasIndexChange = true;\n                    }\n                    var hasMapIndex = decode.numberCheck(bytes, it);\n                    var isSchemaType = typeof (type_1) !== \"string\";\n                    var newKey = (hasMapIndex)\n                        ? mapKeys[decode.number(bytes, it)]\n                        : decode.string(bytes, it);\n                    var item = void 0;\n                    var isNew = (!hasIndexChange && !valueRef[newKey]) || (hasIndexChange && previousKey === undefined && hasMapIndex);\n                    if (isNew && isSchemaType) {\n                        item = new type_1();\n                    }\n                    else if (previousKey !== undefined) {\n                        item = valueRef[previousKey];\n                    }\n                    else {\n                        item = valueRef[newKey];\n                    }\n                    if (decode.nilCheck(bytes, it)) {\n                        it.offset++;\n                        if (item && item.onRemove) {\n                            item.onRemove();\n                        }\n                        if (valueRef.onRemove) {\n                            valueRef.onRemove(item, newKey);\n                        }\n                        delete value[newKey];\n                        continue;\n                    }\n                    else if (!isSchemaType) {\n                        value[newKey] = decodePrimitiveType(type_1, bytes, it);\n                    }\n                    else {\n                        item.decode(bytes, it);\n                        value[newKey] = item;\n                    }\n                    if (isNew) {\n                        if (valueRef.onAdd) {\n                            valueRef.onAdd(item, newKey);\n                        }\n                    }\n                    else if (valueRef.onChange) {\n                        valueRef.onChange(item, newKey);\n                    }\n                }\n            }\n            else {\n                value = decodePrimitiveType(type_1, bytes, it);\n                hasChange = true;\n            }\n            if (hasChange && this_1.onChange) {\n                changes.push({\n                    field: field,\n                    value: change || value,\n                    previousValue: this_1[\"_\" + field]\n                });\n            }\n            this_1[\"_\" + field] = value;\n        };\n        var this_1 = this;\n        while (it.offset < totalBytes) {\n            var state_1 = _loop_1();\n            if (state_1 === \"break\")\n                break;\n        }\n        if (this.onChange && changes.length > 0) {\n            this.onChange(changes);\n        }\n        return this;\n    };\n    Schema.prototype.encode = function (root, encodeAll, client) {\n        var _this = this;\n        if (root === void 0) { root = this; }\n        if (encodeAll === void 0) { encodeAll = false; }\n        var encodedBytes = [];\n        var endStructure = function () {\n            if (_this !== root) {\n                encodedBytes.push(spec_1.END_OF_STRUCTURE);\n            }\n        };\n        // skip if nothing has changed\n        if (!this.$changes.changed && !encodeAll) {\n            endStructure();\n            return encodedBytes;\n        }\n        var schema = this._schema;\n        var indexes = this._indexes;\n        var filters = this._filters;\n        var changes = (encodeAll || client)\n            ? this.$changes.allChanges\n            : this.$changes.changes;\n        for (var i = 0, l = changes.length; i < l; i++) {\n            var field = changes[i];\n            var type_2 = schema[field];\n            var filter_1 = (filters && filters[field]);\n            // const value = (filter && this.$allChanges[field]) || changes[field];\n            var value = this[\"_\" + field];\n            var fieldIndex = indexes[field];\n            // skip unchagned fields\n            if (value === undefined) {\n                continue;\n            }\n            var bytes = [];\n            if (type_2._schema) {\n                if (client && filter_1) {\n                    // skip if not allowed by custom filter\n                    if (!filter_1.call(this, client, value, root)) {\n                        continue;\n                    }\n                }\n                encode.number(bytes, fieldIndex);\n                // encode child object\n                if (value) {\n                    bytes = bytes.concat(value.encode(root, encodeAll, client));\n                }\n                else {\n                    // value has been removed\n                    encode.uint8(bytes, spec_1.NIL);\n                }\n            }\n            else if (Array.isArray(type_2)) {\n                encode.number(bytes, fieldIndex);\n                // total of items in the array\n                encode.number(bytes, value.length);\n                var arrayChanges = (encodeAll || client)\n                    ? value.$changes.allChanges\n                    : value.$changes.changes;\n                // number of changed items\n                encode.number(bytes, arrayChanges.length);\n                // encode Array of type\n                for (var j = 0; j < arrayChanges.length; j++) {\n                    var index = arrayChanges[j];\n                    var item = this[\"_\" + field][index];\n                    if (client && filter_1) {\n                        // skip if not allowed by custom filter\n                        if (!filter_1.call(this, client, item, root)) {\n                            continue;\n                        }\n                    }\n                    if (typeof (type_2[0]) !== \"string\") { // is array of Schema\n                        encode.number(bytes, index);\n                        if (item === undefined) {\n                            encode.uint8(bytes, spec_1.NIL);\n                            continue;\n                        }\n                        var indexChange = value.$changes.getIndexChange(item);\n                        if (indexChange !== undefined) {\n                            encode.uint8(bytes, spec_1.INDEX_CHANGE);\n                            encode.number(bytes, indexChange);\n                        }\n                        bytes = bytes.concat(item.encode(root, encodeAll, client));\n                    }\n                    else {\n                        encode.number(bytes, index);\n                        if (!encodePrimitiveType(type_2[0], bytes, item)) {\n                            console.log(\"cannot encode\", schema[field]);\n                            continue;\n                        }\n                    }\n                }\n                value.$changes.discard();\n            }\n            else if (type_2.map) {\n                // encode Map of type\n                encode.number(bytes, fieldIndex);\n                // TODO: during `encodeAll`, removed entries are not going to be encoded\n                var keys = (encodeAll || client)\n                    ? value.$changes.allChanges\n                    : value.$changes.changes;\n                encode.number(bytes, keys.length);\n                var mapKeys = Object.keys(this[\"_\" + field]);\n                for (var i_1 = 0; i_1 < keys.length; i_1++) {\n                    var key = mapKeys[keys[i_1]] || keys[i_1];\n                    var item = this[\"_\" + field][key];\n                    var mapItemIndex = this[\"_\" + field]._indexes[key];\n                    if (client && filter_1) {\n                        // skip if not allowed by custom filter\n                        if (!filter_1.call(this, client, item, root)) {\n                            continue;\n                        }\n                    }\n                    if (encodeAll) {\n                        if (item !== undefined) {\n                            mapItemIndex = undefined;\n                        }\n                        else {\n                            // previously deleted items are skipped during `encodeAll`\n                            continue;\n                        }\n                    }\n                    // encode index change\n                    var indexChange = value.$changes.getIndexChange(item);\n                    if (item && indexChange !== undefined) {\n                        encode.uint8(bytes, spec_1.INDEX_CHANGE);\n                        encode.number(bytes, this[\"_\" + field]._indexes[indexChange]);\n                    }\n                    if (mapItemIndex !== undefined) {\n                        encode.number(bytes, mapItemIndex);\n                    }\n                    else {\n                        // TODO: remove item\n                        encode.string(bytes, key);\n                    }\n                    if (item instanceof Schema) {\n                        bytes = bytes.concat(item.encode(root, encodeAll, client));\n                    }\n                    else if (item !== undefined) {\n                        encodePrimitiveType(type_2.map, bytes, item);\n                    }\n                    else {\n                        encode.uint8(bytes, spec_1.NIL);\n                    }\n                }\n                value.$changes.discard();\n                // TODO: track array/map indexes per client?\n                if (!client) {\n                    this[\"_\" + field]._updateIndexes();\n                }\n            }\n            else {\n                if (client && filter_1) {\n                    // skip if not allowed by custom filter\n                    if (!filter_1.call(this, client, value, root)) {\n                        continue;\n                    }\n                }\n                encode.number(bytes, fieldIndex);\n                if (!encodePrimitiveType(type_2, bytes, value)) {\n                    console.log(\"cannot encode\", schema[field]);\n                    continue;\n                }\n            }\n            encodedBytes = encodedBytes.concat(bytes);\n        }\n        // flag end of Schema object structure\n        endStructure();\n        if (!client) {\n            this.$changes.discard();\n        }\n        return encodedBytes;\n    };\n    Schema.prototype.encodeFiltered = function (client) {\n        return this.encode(this, false, client);\n    };\n    Schema.prototype.encodeAll = function () {\n        return this.encode(this, true);\n    };\n    Schema.prototype.encodeAllFiltered = function (client) {\n        return this.encode(this, true, client);\n    };\n    Schema.prototype.toJSON = function () {\n        var schema = this._schema;\n        var obj = {};\n        for (var field in schema) {\n            obj[field] = this[\"_\" + field];\n        }\n        return obj;\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n/**\n * Reflection\n */\nvar ReflectionField = /** @class */ (function (_super) {\n    __extends(ReflectionField, _super);\n    function ReflectionField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        type(\"string\")\n    ], ReflectionField.prototype, \"name\", void 0);\n    __decorate([\n        type(\"string\")\n    ], ReflectionField.prototype, \"type\", void 0);\n    __decorate([\n        type(\"uint8\")\n    ], ReflectionField.prototype, \"referencedType\", void 0);\n    return ReflectionField;\n}(Schema));\nexports.ReflectionField = ReflectionField;\nvar ReflectionType = /** @class */ (function (_super) {\n    __extends(ReflectionType, _super);\n    function ReflectionType() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.fields = new ArraySchema_1.ArraySchema();\n        return _this;\n    }\n    __decorate([\n        type(\"uint8\")\n    ], ReflectionType.prototype, \"id\", void 0);\n    __decorate([\n        type([ReflectionField])\n    ], ReflectionType.prototype, \"fields\", void 0);\n    return ReflectionType;\n}(Schema));\nexports.ReflectionType = ReflectionType;\nvar Reflection = /** @class */ (function (_super) {\n    __extends(Reflection, _super);\n    function Reflection() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.types = new ArraySchema_1.ArraySchema();\n        return _this;\n    }\n    Reflection.encode = function (instance) {\n        var reflection = new Reflection();\n        var schema = instance._schema;\n        var lastTypeId = 0;\n        var rootType = new ReflectionType();\n        rootType.id = lastTypeId++;\n        var typeIds = {};\n        var buildType = function (currentType, schema) {\n            for (var fieldName in schema) {\n                var field = new ReflectionField();\n                field.name = fieldName;\n                var fieldType = void 0;\n                if (typeof (schema[fieldName]) === \"string\") {\n                    fieldType = schema[fieldName];\n                }\n                else {\n                    var isSchema = typeof (schema[fieldName]) === \"function\";\n                    var isArray = Array.isArray(schema[fieldName]);\n                    var isMap = !isArray && schema[fieldName].map;\n                    var childTypeSchema = void 0;\n                    if (isSchema) {\n                        fieldType = \"ref\";\n                        childTypeSchema = schema[fieldName];\n                    }\n                    else if (isArray) {\n                        fieldType = \"array\";\n                        if (typeof (schema[fieldName][0]) === \"string\") {\n                            fieldType += \":\" + schema[fieldName][0]; // array:string\n                        }\n                        else {\n                            childTypeSchema = schema[fieldName][0];\n                        }\n                    }\n                    else if (isMap) {\n                        fieldType = \"map\";\n                        if (typeof (schema[fieldName].map) === \"string\") {\n                            fieldType += \":\" + schema[fieldName].map; // array:string\n                        }\n                        else {\n                            childTypeSchema = schema[fieldName].map;\n                        }\n                    }\n                    if (childTypeSchema) {\n                        var childSchemaName = childTypeSchema.name;\n                        if (typeIds[childSchemaName] === undefined) {\n                            var childType = new ReflectionType();\n                            childType.id = lastTypeId++;\n                            typeIds[childSchemaName] = childType.id;\n                            buildType(childType, childTypeSchema._schema);\n                        }\n                        field.referencedType = typeIds[childSchemaName];\n                    }\n                    else {\n                        field.referencedType = 255;\n                    }\n                }\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n            reflection.types.push(currentType);\n        };\n        buildType(rootType, schema);\n        return reflection.encodeAll();\n    };\n    Reflection.decode = function (bytes) {\n        var reflection = new Reflection();\n        reflection.decode(bytes);\n        var schemaTypes = reflection.types.reduce(function (types, reflectionType) {\n            types[reflectionType.id] = /** @class */ (function (_super) {\n                __extends(_, _super);\n                function _() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return _;\n            }(Schema));\n            return types;\n        }, {});\n        reflection.types.forEach(function (reflectionType, i) {\n            reflectionType.fields.forEach(function (field) {\n                var schemaType = schemaTypes[reflectionType.id];\n                if (field.referencedType !== undefined) {\n                    var refType = schemaTypes[field.referencedType];\n                    // map or array of primitive type (255)\n                    if (!refType) {\n                        refType = field.type.split(\":\")[1];\n                    }\n                    if (field.type.indexOf(\"array\") === 0) {\n                        type([refType])(schemaType.prototype, field.name);\n                    }\n                    else if (field.type.indexOf(\"map\") === 0) {\n                        type({ map: refType })(schemaType.prototype, field.name);\n                    }\n                    else if (field.type === \"ref\") {\n                        type(refType)(schemaType.prototype, field.name);\n                    }\n                }\n                else {\n                    type(field.type)(schemaType.prototype, field.name);\n                }\n            });\n        });\n        var rootType = schemaTypes[0];\n        var rootInstance = new rootType();\n        /**\n         * auto-initialize referenced types on root type\n         * to allow registering listeners immediatelly on client-side\n         */\n        for (var fieldName in rootType._schema) {\n            var fieldType = rootType._schema[fieldName];\n            if (typeof (fieldType) !== \"string\") {\n                var isSchema = typeof (fieldType) === \"function\";\n                var isArray = Array.isArray(fieldType);\n                var isMap = !isArray && fieldType.map;\n                rootInstance[fieldName] = (isArray)\n                    ? new ArraySchema_1.ArraySchema()\n                    : (isMap)\n                        ? new MapSchema_1.MapSchema()\n                        : (isSchema)\n                            ? new fieldType()\n                            : undefined;\n            }\n        }\n        return rootInstance;\n    };\n    __decorate([\n        type([ReflectionType])\n    ], Reflection.prototype, \"types\", void 0);\n    return Reflection;\n}(Schema));\nexports.Reflection = Reflection;\n/**\n * `@type()` decorator for proxies\n */\nfunction type(type) {\n    return function (target, field) {\n        var constructor = target.constructor;\n        /*\n         * static schema\n         */\n        if (!definedSchemas.get(constructor)) {\n            definedSchemas.set(constructor, true);\n            // support inheritance\n            constructor._schema = Object.assign({}, constructor._schema || {});\n            constructor._indexes = Object.assign({}, constructor._indexes || {});\n            constructor._descriptors = Object.assign({}, constructor._descriptors || {});\n        }\n        constructor._indexes[field] = Object.keys(constructor._schema).length;\n        constructor._schema[field] = type;\n        /**\n         * TODO: `isSchema` / `isArray` / `isMap` is repeated on many places!\n         * need to refactor all of them.\n         */\n        var isArray = Array.isArray(type);\n        var isMap = !isArray && type.map;\n        var fieldCached = \"_\" + field;\n        constructor._descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n        constructor._descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n            set: function (value) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n                if (isArray || isMap) {\n                    value = new Proxy(value, {\n                        get: function (obj, prop) { return obj[prop]; },\n                        set: function (obj, prop, setValue) {\n                            if (prop !== \"length\" && prop !== \"$changes\") {\n                                // ensure new value has a parent\n                                var key = (isArray) ? Number(prop) : String(prop);\n                                var previousIndex = obj.$changes.getIndex(setValue);\n                                if (previousIndex !== undefined) {\n                                    obj.$changes.mapIndexChange(setValue, previousIndex);\n                                }\n                                obj.$changes.mapIndex(setValue, key);\n                                if (setValue instanceof Schema) {\n                                    // new items are flagged with all changes\n                                    if (!setValue.$changes.parent) {\n                                        setValue.$changes = new ChangeTree_1.ChangeTree(key, obj.$changes);\n                                        setValue.$changes.changeAll(setValue);\n                                    }\n                                }\n                                else {\n                                    obj[prop] = setValue;\n                                }\n                                // apply change on ArraySchema / MapSchema\n                                obj.$changes.change(key);\n                            }\n                            else if (setValue !== obj[prop]) {\n                                // console.log(\"SET NEW LENGTH:\", setValue);\n                                // console.log(\"PREVIOUS LENGTH: \", obj[prop]);\n                            }\n                            obj[prop] = setValue;\n                            return true;\n                        },\n                        deleteProperty: function (obj, prop) {\n                            var deletedValue = obj[prop];\n                            // TODO: \n                            // remove deleteIndex of property being deleted as well.\n                            // obj.$changes.deleteIndex(deletedValue);\n                            // obj.$changes.deleteIndexChange(deletedValue);\n                            delete obj[prop];\n                            var key = (isArray) ? Number(prop) : String(prop);\n                            obj.$changes.change(key);\n                            return true;\n                        },\n                    });\n                }\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n                this[fieldCached] = value;\n                if (Array.isArray(constructor._schema[field])) {\n                    // directly assigning an array of items as value.\n                    this.$changes.change(field);\n                    value.$changes = new ChangeTree_1.ChangeTree(field, this.$changes);\n                    for (var i = 0; i < value.length; i++) {\n                        if (value[i] instanceof Schema) {\n                            value[i].$changes = new ChangeTree_1.ChangeTree(i, value.$changes);\n                            value[i].$changes.changeAll(value[i]);\n                        }\n                        value.$changes.mapIndex(value[i], i);\n                        value.$changes.change(i);\n                    }\n                }\n                else if (constructor._schema[field].map) {\n                    // directly assigning a map\n                    value.$changes = new ChangeTree_1.ChangeTree(field, this.$changes);\n                    this.$changes.change(field);\n                    for (var key in value) {\n                        if (value[key] instanceof Schema) {\n                            value[key].$changes = new ChangeTree_1.ChangeTree(key, value.$changes);\n                            value[key].$changes.changeAll(value[key]);\n                        }\n                        value.$changes.mapIndex(value[key], key);\n                        value.$changes.change(key);\n                    }\n                }\n                else if (typeof (constructor._schema[field]) === \"function\") {\n                    // directly assigning a `Schema` object\n                    // value may be set to null\n                    this.$changes.change(field);\n                    if (value) {\n                        value.$changes = new ChangeTree_1.ChangeTree(field, this.$changes);\n                        value.$changes.changeAll(value);\n                    }\n                }\n                else {\n                    // directly assigning a primitive type\n                    this.$changes.change(field);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        };\n    };\n}\nexports.type = type;\n/**\n * `@filter()` decorator for defining data filters per client\n */\nfunction filter(cb) {\n    return function (target, field) {\n        var constructor = target.constructor;\n        /*\n        * static filters\n        */\n        if (!constructor._filters) {\n            constructor._filters = {};\n        }\n        constructor._filters[field] = cb;\n    };\n}\nexports.filter = filter;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/annotations.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/encoding/decode.js":
/*!**************************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/encoding/decode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar spec_1 = __webpack_require__(/*! ../spec */ \"./node_modules/@colyseus/schema/lib/spec.js\");\nfunction utf8Read(bytes, offset, length) {\n    var string = '', chr = 0;\n    for (var i = offset, end = offset + length; i < end; i++) {\n        var byte = bytes[i];\n        if ((byte & 0x80) === 0x00) {\n            string += String.fromCharCode(byte);\n            continue;\n        }\n        if ((byte & 0xe0) === 0xc0) {\n            string += String.fromCharCode(((byte & 0x1f) << 6) |\n                (bytes[++i] & 0x3f));\n            continue;\n        }\n        if ((byte & 0xf0) === 0xe0) {\n            string += String.fromCharCode(((byte & 0x0f) << 12) |\n                ((bytes[++i] & 0x3f) << 6) |\n                ((bytes[++i] & 0x3f) << 0));\n            continue;\n        }\n        if ((byte & 0xf8) === 0xf0) {\n            chr = ((byte & 0x07) << 18) |\n                ((bytes[++i] & 0x3f) << 12) |\n                ((bytes[++i] & 0x3f) << 6) |\n                ((bytes[++i] & 0x3f) << 0);\n            if (chr >= 0x010000) { // surrogate pair\n                chr -= 0x010000;\n                string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n            }\n            else {\n                string += String.fromCharCode(chr);\n            }\n            continue;\n        }\n        throw new Error('Invalid byte ' + byte.toString(16));\n    }\n    return string;\n}\nfunction _str(bytes, it, length) {\n    var value = utf8Read(bytes, it.offset, length);\n    it.offset += length;\n    return value;\n}\n;\nfunction int8(bytes, it) {\n    return uint8(bytes, it) << 24 >> 24;\n}\nexports.int8 = int8;\n;\nfunction uint8(bytes, it) {\n    return bytes[it.offset++];\n}\nexports.uint8 = uint8;\n;\nfunction int16(bytes, it) {\n    return uint16(bytes, it) << 16 >> 16;\n}\nexports.int16 = int16;\n;\nfunction uint16(bytes, it) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8;\n}\nexports.uint16 = uint16;\n;\nfunction int32(bytes, it) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n}\nexports.int32 = int32;\n;\nfunction uint32(bytes, it) {\n    return int32(bytes, it) >>> 0;\n}\nexports.uint32 = uint32;\n;\nfunction float32(bytes, it) {\n    return readFloat32(bytes, it);\n}\nexports.float32 = float32;\nfunction float64(bytes, it) {\n    return readFloat64(bytes, it);\n}\nexports.float64 = float64;\n// export function int64 (bytes: number[], it: Iterator) {\n//     return new flatbuffers.Long(int32(bytes, it), int32(bytes, it));\n// };\n// export function uint64 (bytes: number[], it: Iterator) {\n//     return new flatbuffers.Long(uint32(bytes, it), uint32(bytes, it));\n// };\n// force little endian to facilitate decoding on multiple implementations\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nvar _int32 = new Int32Array(2);\nvar _float32 = new Float32Array(_int32.buffer);\nvar _float64 = new Float64Array(_int32.buffer);\nfunction readFloat32(bytes, it) {\n    _int32[0] = int32(bytes, it);\n    return _float32[0];\n}\nexports.readFloat32 = readFloat32;\n;\nfunction readFloat64(bytes, it) {\n    _int32[_isLittleEndian ? 0 : 1] = int32(bytes, it);\n    _int32[_isLittleEndian ? 1 : 0] = int32(bytes, it);\n    return _float64[0];\n}\nexports.readFloat64 = readFloat64;\n;\nfunction boolean(bytes, it) {\n    return uint8(bytes, it) > 0;\n}\nexports.boolean = boolean;\n;\nfunction string(bytes, it) {\n    var prefix = bytes[it.offset++];\n    return _str(bytes, it, prefix & 0x1f);\n}\nexports.string = string;\nfunction stringCheck(bytes, it) {\n    var prefix = bytes[it.offset];\n    return (\n    // fixstr\n    (prefix < 0xc0 && prefix > 0xa0) ||\n        // str 8\n        prefix === 0xd9 ||\n        // str 16\n        prefix === 0xda ||\n        // str 32\n        prefix === 0xdb);\n}\nexports.stringCheck = stringCheck;\nfunction number(bytes, it) {\n    var prefix = bytes[it.offset++];\n    if (prefix < 0x80) {\n        // positive fixint\n        return prefix;\n    }\n    else if (prefix === 0xca) {\n        // float\n        var value = bytes[it.offset];\n        it.offset += 4;\n        return value;\n    }\n    else if (prefix === 0xca) {\n        // float 32\n        return readFloat32(bytes, it);\n    }\n    else if (prefix === 0xcb) {\n        // float 64\n        return readFloat64(bytes, it);\n    }\n    else if (prefix === 0xcc) {\n        // uint 8\n        return uint8(bytes, it);\n    }\n    else if (prefix === 0xcd) {\n        // uint 16\n        return uint16(bytes, it);\n    }\n    else if (prefix === 0xce) {\n        // uint 32\n        return uint32(bytes, it);\n    }\n    else if (prefix === 0xcf) {\n        // uint 64\n        var hi = bytes[it.offset] * Math.pow(2, 32);\n        var lo = bytes[it.offset + 4];\n        it.offset += 8;\n        return hi + lo;\n    }\n    else if (prefix === 0xd0) {\n        // int 8\n        return int8(bytes, it);\n    }\n    else if (prefix === 0xd1) {\n        // int 16\n        return int16(bytes, it);\n    }\n    else if (prefix === 0xd2) {\n        // int 32\n        return int32(bytes, it);\n    }\n    else if (prefix === 0xd3) {\n        // int 64\n        var hi = bytes[it.offset] * Math.pow(2, 32);\n        var lo = bytes[it.offset + 4];\n        it.offset += 8;\n        return hi + lo;\n    }\n    else if (prefix > 0xdf) {\n        // negative fixint\n        return (0xff - prefix + 1) * -1;\n    }\n}\nexports.number = number;\n;\nfunction numberCheck(bytes, it) {\n    var prefix = bytes[it.offset];\n    // positive fixint - 0x00 - 0x7f\n    // float 32        - 0xca\n    // float 64        - 0xcb\n    // uint 8          - 0xcc\n    // uint 16         - 0xcd\n    // uint 32         - 0xce\n    // uint 64         - 0xcf\n    // int 8           - 0xd0\n    // int 16          - 0xd1\n    // int 32          - 0xd2\n    // int 64          - 0xd3\n    return (prefix < 0x80 ||\n        (prefix >= 0xca && prefix <= 0xd3));\n}\nexports.numberCheck = numberCheck;\nfunction arrayCheck(bytes, it) {\n    return bytes[it.offset] < 0xa0;\n    // const prefix = bytes[it.offset] ;\n    // if (prefix < 0xa0) {\n    //   return prefix;\n    // // array\n    // } else if (prefix === 0xdc) {\n    //   it.offset += 2;\n    // } else if (0xdd) {\n    //   it.offset += 4;\n    // }\n    // return prefix;\n}\nexports.arrayCheck = arrayCheck;\nfunction nilCheck(bytes, it) {\n    return bytes[it.offset] === spec_1.NIL;\n}\nexports.nilCheck = nilCheck;\nfunction indexChangeCheck(bytes, it) {\n    return bytes[it.offset] === spec_1.INDEX_CHANGE;\n}\nexports.indexChangeCheck = indexChangeCheck;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/encoding/decode.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/encoding/encode.js":
/*!**************************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/encoding/encode.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Copyright (c) 2018 Endel Dreyer\n * Copyright (c) 2014 Ion Drive Software Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * msgpack implementation highly based on notepack.io\n * https://github.com/darrachequesne/notepack\n */\nfunction utf8Length(str) {\n    var c = 0, length = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\nfunction utf8Write(view, offset, str) {\n    var c = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            view[offset++] = c;\n        }\n        else if (c < 0x800) {\n            view[offset++] = 0xc0 | (c >> 6);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            view[offset++] = 0xe0 | (c >> 12);\n            view[offset++] = 0x80 | (c >> 6 & 0x3f);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n        else {\n            i++;\n            c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n            view[offset++] = 0xf0 | (c >> 18);\n            view[offset++] = 0x80 | (c >> 12 & 0x3f);\n            view[offset++] = 0x80 | (c >> 6 & 0x3f);\n            view[offset++] = 0x80 | (c & 0x3f);\n        }\n    }\n}\nexports.utf8Write = utf8Write;\nfunction int8(bytes, value) {\n    bytes.push(value);\n}\nexports.int8 = int8;\n;\nfunction uint8(bytes, value) {\n    bytes.push(value);\n}\nexports.uint8 = uint8;\n;\nfunction int16(bytes, value) {\n    bytes.push(value);\n    bytes.push(value >> 8);\n}\nexports.int16 = int16;\n;\nfunction uint16(bytes, value) {\n    bytes.push(value);\n    bytes.push(value >> 8);\n}\nexports.uint16 = uint16;\n;\nfunction int32(bytes, value) {\n    bytes.push(value);\n    bytes.push(value >> 8);\n    bytes.push(value >> 16);\n    bytes.push(value >> 24);\n}\nexports.int32 = int32;\n;\nfunction uint32(bytes, value) {\n    bytes.push(value);\n    bytes.push(value >> 8);\n    bytes.push(value >> 16);\n    bytes.push(value >> 24);\n}\nexports.uint32 = uint32;\n;\nfunction int64(bytes, value) {\n    int32(bytes, value.low);\n    int32(bytes, value.high);\n}\nexports.int64 = int64;\n;\nfunction uint64(bytes, value) {\n    uint32(bytes, value.low);\n    uint32(bytes, value.high);\n}\nexports.uint64 = uint64;\n;\nfunction float32(bytes, value) {\n    writeFloat32(bytes, value);\n}\nexports.float32 = float32;\nfunction float64(bytes, value) {\n    writeFloat64(bytes, value);\n}\nexports.float64 = float64;\n// force little endian to facilitate decoding on multiple implementations\nvar _isLittleEndian = true; // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nvar _int32 = new Int32Array(2);\nvar _float32 = new Float32Array(_int32.buffer);\nvar _float64 = new Float64Array(_int32.buffer);\nfunction writeFloat32(bytes, value) {\n    _float32[0] = value;\n    int32(bytes, _int32[0]);\n}\nexports.writeFloat32 = writeFloat32;\n;\nfunction writeFloat64(bytes, value) {\n    _float64[0] = value;\n    int32(bytes, _int32[_isLittleEndian ? 0 : 1]);\n    int32(bytes, _int32[_isLittleEndian ? 1 : 0]);\n}\nexports.writeFloat64 = writeFloat64;\n;\nfunction boolean(bytes, value) {\n    return uint8(bytes, value ? 1 : 0);\n}\nexports.boolean = boolean;\n;\nfunction string(bytes, value) {\n    var length = utf8Length(value);\n    var size = 0;\n    // fixstr\n    if (length < 0x20) {\n        bytes.push(length | 0xa0);\n        size = 1;\n    }\n    // str 8\n    else if (length < 0x100) {\n        bytes.push(0xd9, length);\n        size = 2;\n    }\n    // str 16\n    else if (length < 0x10000) {\n        bytes.push(0xda, length >> 8, length);\n        size = 3;\n    }\n    // str 32\n    else if (length < 0x100000000) {\n        bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n    }\n    else {\n        throw new Error('String too long');\n    }\n    // defers.push({ _str: value, _length: length, _offset: bytes.length });\n    utf8Write(bytes, bytes.length, value);\n    return size + length;\n}\nexports.string = string;\nfunction number(bytes, value) {\n    // float 64\n    if (Math.floor(value) !== value || !isFinite(value)) {\n        /**\n         * TODO:\n         * is it possible to differentiate between float32 / float64 here?\n         */\n        bytes.push(0xcb);\n        writeFloat64(bytes, value);\n        return 9;\n    }\n    if (value >= 0) {\n        // positive fixnum\n        if (value < 0x80) {\n            uint8(bytes, value);\n            return 1;\n        }\n        // uint 8\n        if (value < 0x100) {\n            bytes.push(0xcc);\n            uint8(bytes, value);\n            return 2;\n        }\n        // uint 16\n        if (value < 0x10000) {\n            bytes.push(0xcd);\n            uint16(bytes, value);\n            return 3;\n        }\n        // uint 32\n        if (value < 0x100000000) {\n            bytes.push(0xce);\n            uint32(bytes, value);\n            return 5;\n        }\n        // uint 64\n        bytes.push(0xcf);\n        uint64(bytes, value);\n        return 9;\n    }\n    else {\n        // negative fixnum\n        if (value >= -0x20) {\n            bytes.push(value);\n            return 1;\n        }\n        // int 8\n        if (value >= -0x80) {\n            bytes.push(0xd0);\n            int8(bytes, value);\n            return 2;\n        }\n        // int 16\n        if (value >= -0x8000) {\n            bytes.push(0xd1);\n            int16(bytes, value);\n            return 3;\n        }\n        // int 32\n        if (value >= -0x80000000) {\n            bytes.push(0xd2);\n            int32(bytes, value);\n            return 5;\n        }\n        // int 64\n        bytes.push(0xd3);\n        int64(bytes, value);\n        return 9;\n    }\n}\nexports.number = number;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/encoding/encode.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MapSchema_1 = __webpack_require__(/*! ./types/MapSchema */ \"./node_modules/@colyseus/schema/lib/types/MapSchema.js\");\nexports.MapSchema = MapSchema_1.MapSchema;\nvar ArraySchema_1 = __webpack_require__(/*! ./types/ArraySchema */ \"./node_modules/@colyseus/schema/lib/types/ArraySchema.js\");\nexports.ArraySchema = ArraySchema_1.ArraySchema;\nvar annotations_1 = __webpack_require__(/*! ./annotations */ \"./node_modules/@colyseus/schema/lib/annotations.js\");\n// Public API\nexports.Schema = annotations_1.Schema;\nexports.type = annotations_1.type;\nexports.filter = annotations_1.filter;\n// Reflection\nexports.Reflection = annotations_1.Reflection;\nexports.ReflectionType = annotations_1.ReflectionType;\nexports.ReflectionField = annotations_1.ReflectionField;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/index.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/spec.js":
/*!***************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/spec.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.END_OF_STRUCTURE = 0xc1; // (msgpack spec: never used)\nexports.NIL = 0xc0;\nexports.INDEX_CHANGE = 0xd4;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/spec.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/types/ArraySchema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/types/ArraySchema.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ArraySchema = /** @class */ (function (_super) {\n    __extends(ArraySchema, _super);\n    function ArraySchema() {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, items) || this;\n        Object.setPrototypeOf(_this, Object.create(ArraySchema.prototype));\n        Object.defineProperties(_this, {\n            $changes: { value: undefined, enumerable: false, writable: true },\n            onAdd: { value: undefined, enumerable: false, writable: true },\n            onRemove: { value: undefined, enumerable: false, writable: true },\n            onChange: { value: undefined, enumerable: false, writable: true },\n            clone: {\n                value: function () {\n                    var arr = new (ArraySchema.bind.apply(ArraySchema, [void 0].concat(_this)))();\n                    arr.onAdd = _this.onAdd;\n                    arr.onRemove = _this.onRemove;\n                    arr.onChange = _this.onChange;\n                    return arr;\n                }\n            }\n        });\n        return _this;\n    }\n    Object.defineProperty(ArraySchema, Symbol.species, {\n        get: function () { return Array; },\n        enumerable: true,\n        configurable: true\n    });\n    return ArraySchema;\n}(Array));\nexports.ArraySchema = ArraySchema;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/types/ArraySchema.js?");

/***/ }),

/***/ "./node_modules/@colyseus/schema/lib/types/MapSchema.js":
/*!**************************************************************!*\
  !*** ./node_modules/@colyseus/schema/lib/types/MapSchema.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MapSchema = /** @class */ (function () {\n    function MapSchema(obj) {\n        if (obj === void 0) { obj = {}; }\n        var _this = this;\n        for (var key in obj) {\n            this[key] = obj[key];\n        }\n        Object.defineProperties(this, {\n            $changes: { value: undefined, enumerable: false, writable: true },\n            onAdd: { value: undefined, enumerable: false, writable: true },\n            onRemove: { value: undefined, enumerable: false, writable: true },\n            onChange: { value: undefined, enumerable: false, writable: true },\n            clone: {\n                value: function () {\n                    var map = Object.assign(new MapSchema(), _this);\n                    map.onAdd = _this.onAdd;\n                    map.onRemove = _this.onRemove;\n                    map.onChange = _this.onChange;\n                    return map;\n                }\n            },\n            _indexes: { value: {}, enumerable: false, writable: true },\n            _updateIndexes: {\n                value: function () {\n                    var index = 0;\n                    var indexes = {};\n                    for (var key in _this) {\n                        indexes[key] = index++;\n                    }\n                    _this._indexes = indexes;\n                }\n            },\n        });\n    }\n    return MapSchema;\n}());\nexports.MapSchema = MapSchema;\n\n\n//# sourceURL=webpack:///./node_modules/@colyseus/schema/lib/types/MapSchema.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/signals/lib/OnceSignal.js":
/*!***********************************************************!*\
  !*** ./node_modules/@gamestdio/signals/lib/OnceSignal.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SlotList_1 = __webpack_require__(/*! ./SlotList */ \"./node_modules/@gamestdio/signals/lib/SlotList.js\");\nvar Slot_1 = __webpack_require__(/*! ./Slot */ \"./node_modules/@gamestdio/signals/lib/Slot.js\");\nvar OnceSignal = (function () {\n    function OnceSignal() {\n        var valueClasses = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            valueClasses[_i] = arguments[_i];\n        }\n        this.slots = SlotList_1.SlotList.NIL;\n        this.valueClasses = valueClasses.length === 1 && valueClasses[0] instanceof Array ? valueClasses[0] : valueClasses;\n    }\n    Object.defineProperty(OnceSignal.prototype, \"valueClasses\", {\n        get: function () {\n            return this._valueClasses;\n        },\n        set: function (value) {\n            this._valueClasses = value ? value.slice() : [];\n            for (var i = this._valueClasses.length; i--;) {\n                if (!(this._valueClasses[i] instanceof Object)) {\n                    throw new Error(\"Invalid valueClasses argument: \" +\n                        \"item at index \" +\n                        i +\n                        \" should be a Class but was:<\" +\n                        this._valueClasses[i] +\n                        \">.\" +\n                        this._valueClasses[i]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OnceSignal.prototype, \"numListeners\", {\n        get: function () {\n            return this.slots.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OnceSignal.prototype.addOnce = function (listener) {\n        return this.registerListener(listener, true);\n    };\n    OnceSignal.prototype.once = function (listener) {\n        return this.addOnce(listener);\n    };\n    OnceSignal.prototype.remove = function (listener) {\n        var slot = this.slots.find(listener);\n        if (!slot) {\n            return null;\n        }\n        this.slots = this.slots.filterNot(listener);\n        return slot;\n    };\n    OnceSignal.prototype.removeAll = function () {\n        this.slots = SlotList_1.SlotList.NIL;\n    };\n    OnceSignal.prototype.dispatch = function () {\n        var valueObjects = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            valueObjects[_i] = arguments[_i];\n        }\n        var numValueClasses = this._valueClasses.length;\n        var numValueObjects = valueObjects.length;\n        if (numValueObjects < numValueClasses) {\n            throw new Error(\"Incorrect number of arguments. \" + \"Expected at least \" + numValueClasses + \" but received \" + numValueObjects + \".\");\n        }\n        for (var i = 0; i < numValueClasses; i++) {\n            if (valueObjects[i] === null ||\n                (valueObjects[i] instanceof this._valueClasses[i] || valueObjects[i].constructor === this._valueClasses[i])) {\n                continue;\n            }\n            throw new Error(\"Value object <\" + valueObjects[i] + \"> is not an instance of <\" + this._valueClasses[i] + \">.\");\n        }\n        var slotsToProcess = this.slots;\n        if (slotsToProcess.nonEmpty) {\n            while (slotsToProcess.nonEmpty) {\n                slotsToProcess.head.execute(valueObjects);\n                slotsToProcess = slotsToProcess.tail;\n            }\n        }\n    };\n    OnceSignal.prototype.registerListener = function (listener, once) {\n        if (once === void 0) { once = false; }\n        if (this.registrationPossible(listener, once)) {\n            var newSlot = new Slot_1.Slot(listener, this, once);\n            this.slots = this.slots.prepend(newSlot);\n            return newSlot;\n        }\n        return this.slots.find(listener);\n    };\n    OnceSignal.prototype.registrationPossible = function (listener, once) {\n        if (!this.slots.nonEmpty) {\n            return true;\n        }\n        var existingSlot = this.slots.find(listener);\n        if (!existingSlot) {\n            return true;\n        }\n        if (existingSlot.once !== once) {\n            throw new Error(\"You cannot addOnce() then add() the same listener without removing the relationship first.\");\n        }\n        return false;\n    };\n    return OnceSignal;\n}());\nexports.OnceSignal = OnceSignal;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/signals/lib/OnceSignal.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/signals/lib/Signal.js":
/*!*******************************************************!*\
  !*** ./node_modules/@gamestdio/signals/lib/Signal.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OnceSignal_1 = __webpack_require__(/*! ./OnceSignal */ \"./node_modules/@gamestdio/signals/lib/OnceSignal.js\");\nvar Signal = (function (_super) {\n    __extends(Signal, _super);\n    function Signal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Signal.prototype.add = function (listener) {\n        return this.registerListener(listener);\n    };\n    return Signal;\n}(OnceSignal_1.OnceSignal));\nexports.Signal = Signal;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/signals/lib/Signal.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/signals/lib/Slot.js":
/*!*****************************************************!*\
  !*** ./node_modules/@gamestdio/signals/lib/Slot.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Slot = (function () {\n    function Slot(listener, signal, once, priority) {\n        if (once === void 0) { once = false; }\n        if (priority === void 0) { priority = 0; }\n        this._enabled = true;\n        this._once = false;\n        this._priority = 0;\n        this._listener = listener;\n        this._once = once;\n        this._signal = signal;\n        this._priority = priority;\n        this.verifyListener(listener);\n    }\n    Slot.prototype.execute0 = function () {\n        if (!this._enabled) {\n            return;\n        }\n        if (this._once) {\n            this.remove();\n        }\n        if (this._params && this._params.length) {\n            this._listener.apply(null, this._params);\n            return;\n        }\n        this._listener();\n    };\n    Slot.prototype.execute1 = function (value) {\n        if (!this._enabled) {\n            return;\n        }\n        if (this._once) {\n            this.remove();\n        }\n        if (this._params && this._params.length) {\n            this._listener.apply(null, [value].concat(this._params));\n            return;\n        }\n        this._listener(value);\n    };\n    Slot.prototype.execute = function (valueObjects) {\n        if (!this._enabled) {\n            return;\n        }\n        if (this._once) {\n            this.remove();\n        }\n        if (this._params && this._params.length) {\n            valueObjects = valueObjects.concat(this._params);\n        }\n        var numValueObjects = valueObjects.length;\n        if (numValueObjects === 0) {\n            this._listener();\n        }\n        else if (numValueObjects === 1) {\n            this._listener(valueObjects[0]);\n        }\n        else if (numValueObjects === 2) {\n            this._listener(valueObjects[0], valueObjects[1]);\n        }\n        else if (numValueObjects === 3) {\n            this._listener(valueObjects[0], valueObjects[1], valueObjects[2]);\n        }\n        else {\n            this._listener.apply(null, valueObjects);\n        }\n    };\n    Object.defineProperty(Slot.prototype, \"listener\", {\n        get: function () {\n            return this._listener;\n        },\n        set: function (value) {\n            if (null == value) {\n                throw new Error(\"Given listener is null.\\nDid you want to set enabled to false instead?\");\n            }\n            this.verifyListener(value);\n            this._listener = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Slot.prototype, \"once\", {\n        get: function () {\n            return this._once;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Slot.prototype, \"priority\", {\n        get: function () {\n            return this._priority;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Slot.prototype.toString = function () {\n        return (\"[Slot listener: \" +\n            this._listener +\n            \", once: \" +\n            this._once +\n            \", priority: \" +\n            this._priority +\n            \", enabled: \" +\n            this._enabled +\n            \"]\");\n    };\n    Object.defineProperty(Slot.prototype, \"enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            this._enabled = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Slot.prototype, \"params\", {\n        get: function () {\n            return this._params;\n        },\n        set: function (value) {\n            this._params = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Slot.prototype.remove = function () {\n        this._signal.remove(this._listener);\n    };\n    Slot.prototype.verifyListener = function (listener) {\n        if (null == listener) {\n            throw new Error(\"Given listener is null.\");\n        }\n        if (null == this._signal) {\n            throw new Error(\"Internal signal reference has not been set yet.\");\n        }\n    };\n    return Slot;\n}());\nexports.Slot = Slot;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/signals/lib/Slot.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/signals/lib/SlotList.js":
/*!*********************************************************!*\
  !*** ./node_modules/@gamestdio/signals/lib/SlotList.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SlotList = (function () {\n    function SlotList(head, tail) {\n        if (tail === void 0) { tail = null; }\n        this.nonEmpty = false;\n        if (!head && !tail) {\n            if (SlotList.NIL) {\n                throw new Error(\"Parameters head and tail are null. Use the NIL element instead.\");\n            }\n            this.nonEmpty = false;\n        }\n        else if (!head) {\n            throw new Error(\"Parameter head cannot be null.\");\n        }\n        else {\n            this.head = head;\n            this.tail = tail || SlotList.NIL;\n            this.nonEmpty = true;\n        }\n    }\n    Object.defineProperty(SlotList.prototype, \"length\", {\n        get: function () {\n            if (!this.nonEmpty) {\n                return 0;\n            }\n            if (this.tail === SlotList.NIL) {\n                return 1;\n            }\n            var result = 0;\n            var p = this;\n            while (p.nonEmpty) {\n                ++result;\n                p = p.tail;\n            }\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SlotList.prototype.prepend = function (slot) {\n        return new SlotList(slot, this);\n    };\n    SlotList.prototype.append = function (slot) {\n        if (!slot) {\n            return this;\n        }\n        if (!this.nonEmpty) {\n            return new SlotList(slot);\n        }\n        if (this.tail === SlotList.NIL) {\n            return new SlotList(slot).prepend(this.head);\n        }\n        var wholeClone = new SlotList(this.head);\n        var subClone = wholeClone;\n        var current = this.tail;\n        while (current.nonEmpty) {\n            subClone = subClone.tail = new SlotList(current.head);\n            current = current.tail;\n        }\n        subClone.tail = new SlotList(slot);\n        return wholeClone;\n    };\n    SlotList.prototype.insertWithPriority = function (slot) {\n        if (!this.nonEmpty) {\n            return new SlotList(slot);\n        }\n        var priority = slot.priority;\n        if (priority > this.head.priority) {\n            return this.prepend(slot);\n        }\n        var wholeClone = new SlotList(this.head);\n        var subClone = wholeClone;\n        var current = this.tail;\n        while (current.nonEmpty) {\n            if (priority > current.head.priority) {\n                subClone.tail = current.prepend(slot);\n                return wholeClone;\n            }\n            subClone = subClone.tail = new SlotList(current.head);\n            current = current.tail;\n        }\n        subClone.tail = new SlotList(slot);\n        return wholeClone;\n    };\n    SlotList.prototype.filterNot = function (listener) {\n        if (!this.nonEmpty || listener == null) {\n            return this;\n        }\n        if (listener === this.head.listener) {\n            return this.tail;\n        }\n        var wholeClone = new SlotList(this.head);\n        var subClone = wholeClone;\n        var current = this.tail;\n        while (current.nonEmpty) {\n            if (current.head.listener === listener) {\n                subClone.tail = current.tail;\n                return wholeClone;\n            }\n            subClone = subClone.tail = new SlotList(current.head);\n            current = current.tail;\n        }\n        return this;\n    };\n    SlotList.prototype.contains = function (listener) {\n        if (!this.nonEmpty) {\n            return false;\n        }\n        var p = this;\n        while (p.nonEmpty) {\n            if (p.head.listener === listener) {\n                return true;\n            }\n            p = p.tail;\n        }\n        return false;\n    };\n    SlotList.prototype.find = function (listener) {\n        if (!this.nonEmpty) {\n            return null;\n        }\n        var p = this;\n        while (p.nonEmpty) {\n            if (p.head.listener === listener) {\n                return p.head;\n            }\n            p = p.tail;\n        }\n        return null;\n    };\n    SlotList.prototype.toString = function () {\n        var buffer = \"\";\n        var p = this;\n        while (p.nonEmpty) {\n            buffer += p.head + \" -> \";\n            p = p.tail;\n        }\n        buffer += \"NIL\";\n        return \"[List \" + buffer + \"]\";\n    };\n    SlotList.NIL = new SlotList(null, null);\n    return SlotList;\n}());\nexports.SlotList = SlotList;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/signals/lib/SlotList.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/signals/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@gamestdio/signals/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OnceSignal_1 = __webpack_require__(/*! ./OnceSignal */ \"./node_modules/@gamestdio/signals/lib/OnceSignal.js\");\nexports.OnceSignal = OnceSignal_1.OnceSignal;\nvar Signal_1 = __webpack_require__(/*! ./Signal */ \"./node_modules/@gamestdio/signals/lib/Signal.js\");\nexports.Signal = Signal_1.Signal;\nvar Slot_1 = __webpack_require__(/*! ./Slot */ \"./node_modules/@gamestdio/signals/lib/Slot.js\");\nexports.Slot = Slot_1.Slot;\nvar SlotList_1 = __webpack_require__(/*! ./SlotList */ \"./node_modules/@gamestdio/signals/lib/SlotList.js\");\nexports.SlotList = SlotList_1.SlotList;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/signals/lib/index.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/state-listener/lib/StateContainer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@gamestdio/state-listener/lib/StateContainer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar compare_1 = __webpack_require__(/*! ./compare */ \"./node_modules/@gamestdio/state-listener/lib/compare.js\");\nvar StateContainer = /** @class */ (function () {\n    function StateContainer(state) {\n        this.listeners = [];\n        this.matcherPlaceholders = {\n            \":id\": /^([a-zA-Z0-9\\-_]+)$/,\n            \":number\": /^([0-9]+)$/,\n            \":string\": /^(\\w+)$/,\n            \":axis\": /^([xyz])$/,\n            \":*\": /(.*)/,\n        };\n        this.state = state;\n        this.reset();\n    }\n    StateContainer.prototype.set = function (newState) {\n        var patches = compare_1.compare(this.state, newState);\n        this.state = newState;\n        this.checkPatches(patches, this.listeners, this.defaultListener);\n        return patches;\n    };\n    StateContainer.prototype.registerPlaceholder = function (placeholder, matcher) {\n        this.matcherPlaceholders[placeholder] = matcher;\n    };\n    StateContainer.prototype.listen = function (segments, callback, immediate) {\n        var _this = this;\n        var rules;\n        if (typeof (segments) === \"function\") {\n            rules = [];\n            callback = segments;\n        }\n        else {\n            rules = segments.split(\"/\");\n        }\n        if (callback.length > 1) {\n            console.warn(\".listen() accepts only one parameter.\");\n        }\n        var listener = {\n            callback: callback,\n            rawRules: rules,\n            rules: rules.map(function (segment) {\n                if (typeof (segment) === \"string\") {\n                    // replace placeholder matchers\n                    return (segment.indexOf(\":\") === 0)\n                        ? _this.matcherPlaceholders[segment] || _this.matcherPlaceholders[\":*\"]\n                        : new RegExp(\"^\" + segment + \"$\");\n                }\n                else {\n                    return segment;\n                }\n            })\n        };\n        if (rules.length === 0) {\n            this.defaultListener = listener;\n        }\n        else {\n            this.listeners.push(listener);\n        }\n        // immediatelly try to trigger this listener.\n        if (immediate) {\n            this.checkPatches(compare_1.compare({}, this.state), [listener]);\n        }\n        return listener;\n    };\n    StateContainer.prototype.removeListener = function (listener) {\n        for (var i = this.listeners.length - 1; i >= 0; i--) {\n            if (this.listeners[i] === listener) {\n                this.listeners.splice(i, 1);\n            }\n        }\n    };\n    StateContainer.prototype.removeAllListeners = function () {\n        this.reset();\n    };\n    StateContainer.prototype.checkPatches = function (patches, listeners, defaultListener) {\n        for (var j = 0, len = listeners.length; j < len; j++) {\n            var listener = listeners[j];\n            for (var i = patches.length - 1; i >= 0; i--) {\n                var pathVariables = listener && this.getPathVariables(patches[i], listener);\n                if (pathVariables) {\n                    listener.callback({\n                        path: pathVariables,\n                        rawPath: patches[i].path,\n                        operation: patches[i].operation,\n                        value: patches[i].value\n                    });\n                    patches[i].matched = true;\n                }\n            }\n        }\n        // trigger default listener callback with each unmatched patch\n        if (defaultListener) {\n            for (var i = patches.length - 1; i >= 0; i--) {\n                if (!patches[i].matched) {\n                    defaultListener.callback(patches[i]);\n                }\n            }\n        }\n    };\n    StateContainer.prototype.getPathVariables = function (patch, listener) {\n        // skip if rules count differ from patch\n        if (patch.path.length !== listener.rules.length) {\n            return false;\n        }\n        var path = {};\n        for (var i = 0, len = listener.rules.length; i < len; i++) {\n            var matches = patch.path[i].match(listener.rules[i]);\n            if (!matches || matches.length === 0 || matches.length > 2) {\n                return false;\n            }\n            else if (listener.rawRules[i].substr(0, 1) === \":\") {\n                path[listener.rawRules[i].substr(1)] = matches[1];\n            }\n        }\n        return path;\n    };\n    StateContainer.prototype.reset = function () {\n        this.listeners = [];\n    };\n    return StateContainer;\n}());\nexports.StateContainer = StateContainer;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/state-listener/lib/StateContainer.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/state-listener/lib/compare.js":
/*!***************************************************************!*\
  !*** ./node_modules/@gamestdio/state-listener/lib/compare.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction compare(tree1, tree2) {\n    var patches = [];\n    generate(tree1, tree2, patches, []);\n    return patches;\n}\nexports.compare = compare;\nfunction concat(arr, value) {\n    var newArr = arr.slice();\n    newArr.push(value);\n    return newArr;\n}\nfunction objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        var keys_1 = new Array(obj.length);\n        for (var k = 0; k < keys_1.length; k++) {\n            keys_1[k] = \"\" + k;\n        }\n        return keys_1;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n;\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction generate(mirror, obj, patches, path) {\n    var newKeys = objectKeys(obj);\n    var oldKeys = objectKeys(mirror);\n    var deleted = false;\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if (obj.hasOwnProperty(key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null) {\n                generate(oldVal, newVal, patches, concat(path, key));\n            }\n            else {\n                if (oldVal !== newVal) {\n                    patches.push({\n                        operation: \"replace\",\n                        path: concat(path, key),\n                        value: newVal,\n                        previousValue: oldVal\n                    });\n                }\n            }\n        }\n        else {\n            patches.push({ operation: \"remove\", path: concat(path, key) });\n            deleted = true; // property has been deleted\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = newKeys.length - 1; t >= 0; t--) {\n        var key = newKeys[t];\n        if (!mirror.hasOwnProperty(key) && obj[key] !== undefined) {\n            var newVal = obj[key];\n            var addPath = concat(path, key);\n            // compare deeper additions\n            if (typeof newVal == \"object\" && newVal != null) {\n                generate({}, newVal, patches, addPath);\n            }\n            patches.push({ operation: \"add\", path: addPath, value: newVal });\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/state-listener/lib/compare.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/state-listener/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@gamestdio/state-listener/lib/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StateContainer_1 = __webpack_require__(/*! ./StateContainer */ \"./node_modules/@gamestdio/state-listener/lib/StateContainer.js\");\nexports.StateContainer = StateContainer_1.StateContainer;\n\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/state-listener/lib/index.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/websocket/lib/backoff.js":
/*!**********************************************************!*\
  !*** ./node_modules/@gamestdio/websocket/lib/backoff.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports,\"__esModule\",{value:true});exports.createBackoff=createBackoff;var backoff={exponential:function exponential(attempt,delay){return Math.floor(Math.random()*Math.pow(2,attempt)*delay);},fibonacci:function fibonacci(attempt,delay){var current=1;if(attempt>current){var prev=1,current=2;for(var index=2;index<attempt;index++){var next=prev+current;prev=current;current=next;}}return Math.floor(Math.random()*current*delay);}};function createBackoff(type,options){return new Backoff(backoff[type],options);}function Backoff(func,options){this.func=func;this.attempts=0;this.delay=typeof options.initialDelay!==\"undefined\"?options.initialDelay:100;}Backoff.prototype.backoff=function(){setTimeout(this.onReady,this.func(++this.attempts,this.delay));};\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/websocket/lib/backoff.js?");

/***/ }),

/***/ "./node_modules/@gamestdio/websocket/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@gamestdio/websocket/lib/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var createBackoff=__webpack_require__(/*! ./backoff */ \"./node_modules/@gamestdio/websocket/lib/backoff.js\").createBackoff;var WebSocketImpl=typeof WebSocket!==\"undefined\"?WebSocket:__webpack_require__(/*! ws */ 0);var WebSocketClient=function(){/**\n   * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.\n   * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.\n   */function WebSocketClient(url,protocols){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,WebSocketClient);this.url=url;this.protocols=protocols;this.reconnectEnabled=true;this.listeners={};this.backoff=createBackoff(options.backoff||'exponential',options);this.backoff.onReady=this.onBackoffReady.bind(this);if(typeof options.connect===\"undefined\"||options.connect){this.open();}}_createClass(WebSocketClient,[{key:'open',value:function open(){var reconnect=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.isReconnect=reconnect;// keep binaryType used on previous WebSocket connection\nvar binaryType=this.ws&&this.ws.binaryType;this.ws=new WebSocketImpl(this.url,this.protocols);this.ws.onclose=this.onCloseCallback.bind(this);this.ws.onerror=this.onErrorCallback.bind(this);this.ws.onmessage=this.onMessageCallback.bind(this);this.ws.onopen=this.onOpenCallback.bind(this);if(binaryType){this.ws.binaryType=binaryType;}}/**\n   * @ignore\n   */},{key:'onBackoffReady',value:function onBackoffReady(number,delay){// console.log(\"onBackoffReady\", number + ' ' + delay + 'ms');\nthis.open(true);}/**\n   * @ignore\n   */},{key:'onCloseCallback',value:function onCloseCallback(e){if(!this.isReconnect&&this.listeners['onclose']){this.listeners['onclose'].apply(null,arguments);}if(this.reconnectEnabled&&e.code<3000){this.backoff.backoff();}}/**\n   * @ignore\n   */},{key:'onErrorCallback',value:function onErrorCallback(){if(this.listeners['onerror']){this.listeners['onerror'].apply(null,arguments);}}/**\n   * @ignore\n   */},{key:'onMessageCallback',value:function onMessageCallback(){if(this.listeners['onmessage']){this.listeners['onmessage'].apply(null,arguments);}}/**\n   * @ignore\n   */},{key:'onOpenCallback',value:function onOpenCallback(){if(this.listeners['onopen']){this.listeners['onopen'].apply(null,arguments);}if(this.isReconnect&&this.listeners['onreconnect']){this.listeners['onreconnect'].apply(null,arguments);}this.isReconnect=false;}/**\n   * The number of bytes of data that have been queued using calls to send()\n   * but not yet transmitted to the network. This value does not reset to zero\n   * when the connection is closed; if you keep calling send(), this will\n   * continue to climb.\n   *\n   * @type unsigned long\n   * @readonly\n   */},{key:'close',/**\n   * Closes the WebSocket connection or connection attempt, if any. If the\n   * connection is already CLOSED, this method does nothing.\n   *\n   * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal \"transaction complete\" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.\n   * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n   *\n   * @return void\n   */value:function close(code,reason){if(typeof code=='undefined'){code=1000;}this.reconnectEnabled=false;this.ws.close(code,reason);}/**\n   * Transmits data to the server over the WebSocket connection.\n   * @param data DOMString|ArrayBuffer|Blob\n   * @return void\n   */},{key:'send',value:function send(data){this.ws.send(data);}/**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named \"close\".\n   * @param listener EventListener\n   */},{key:'bufferedAmount',get:function get(){return this.ws.bufferedAmount;}/**\n   * The current state of the connection; this is one of the Ready state constants.\n   * @type unsigned short\n   * @readonly\n   */},{key:'readyState',get:function get(){return this.ws.readyState;}/**\n   * A string indicating the type of binary data being transmitted by the\n   * connection. This should be either \"blob\" if DOM Blob objects are being\n   * used or \"arraybuffer\" if ArrayBuffer objects are being used.\n   * @type DOMString\n   */},{key:'binaryType',get:function get(){return this.ws.binaryType;},set:function set(binaryType){this.ws.binaryType=binaryType;}/**\n   * The extensions selected by the server. This is currently only the empty\n   * string or a list of extensions as negotiated by the connection.\n   * @type DOMString\n   */},{key:'extensions',get:function get(){return this.ws.extensions;},set:function set(extensions){this.ws.extensions=extensions;}/**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when\n   * creating the WebSocket object.\n   * @type DOMString\n   */},{key:'protocol',get:function get(){return this.ws.protocol;},set:function set(protocol){this.ws.protocol=protocol;}},{key:'onclose',set:function set(listener){this.listeners['onclose']=listener;},get:function get(){return this.listeners['onclose'];}/**\n   * An event listener to be called when an error occurs. This is a simple event named \"error\".\n   * @param listener EventListener\n   */},{key:'onerror',set:function set(listener){this.listeners['onerror']=listener;},get:function get(){return this.listeners['onerror'];}/**\n   * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named \"message\".\n   * @param listener EventListener\n   */},{key:'onmessage',set:function set(listener){this.listeners['onmessage']=listener;},get:function get(){return this.listeners['onmessage'];}/**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name \"open\".\n   * @param listener EventListener\n   */},{key:'onopen',set:function set(listener){this.listeners['onopen']=listener;},get:function get(){return this.listeners['onopen'];}/**\n   * @param listener EventListener\n   */},{key:'onreconnect',set:function set(listener){this.listeners['onreconnect']=listener;},get:function get(){return this.listeners['onreconnect'];}}]);return WebSocketClient;}();/**\n * The connection is not yet open.\n */WebSocketClient.CONNECTING=WebSocketImpl.CONNECTING;/**\n * The connection is open and ready to communicate.\n */WebSocketClient.OPEN=WebSocketImpl.OPEN;/**\n * The connection is in the process of closing.\n */WebSocketClient.CLOSING=WebSocketImpl.CLOSING;/**\n * The connection is closed or couldn't be opened.\n */WebSocketClient.CLOSED=WebSocketImpl.CLOSED;exports.default=WebSocketClient;\n\n//# sourceURL=webpack:///./node_modules/@gamestdio/websocket/lib/index.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/Client.js":
/*!************************************************!*\
  !*** ./node_modules/colyseus.js/lib/Client.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar msgpack = __webpack_require__(/*! notepack.io */ \"./node_modules/notepack.io/lib/index.js\");\nvar signals_1 = __webpack_require__(/*! @gamestdio/signals */ \"./node_modules/@gamestdio/signals/lib/index.js\");\nvar Connection_1 = __webpack_require__(/*! ./Connection */ \"./node_modules/colyseus.js/lib/Connection.js\");\nvar Protocol_1 = __webpack_require__(/*! ./Protocol */ \"./node_modules/colyseus.js/lib/Protocol.js\");\nvar Room_1 = __webpack_require__(/*! ./Room */ \"./node_modules/colyseus.js/lib/Room.js\");\nvar Storage_1 = __webpack_require__(/*! ./Storage */ \"./node_modules/colyseus.js/lib/Storage.js\");\nvar Client = /** @class */ (function () {\n    function Client(url, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        // signals\n        this.onOpen = new signals_1.Signal();\n        this.onClose = new signals_1.Signal();\n        this.onError = new signals_1.Signal();\n        this.rooms = {};\n        this.connectingRooms = {};\n        this.requestId = 0;\n        this.roomsAvailableRequests = {};\n        this.hostname = url;\n        Storage_1.getItem('colyseusid', function (colyseusid) { return _this.connect(colyseusid, options); });\n    }\n    Client.prototype.join = function (roomName, options) {\n        if (options === void 0) { options = {}; }\n        return this.createRoomRequest(roomName, options);\n    };\n    Client.prototype.rejoin = function (roomName, options) {\n        if (!options.sessionId) {\n            throw new Error(\"'sessionId' options is required for 'rejoin'.\");\n        }\n        return this.join(roomName, options);\n    };\n    Client.prototype.getAvailableRooms = function (roomName, callback) {\n        var _this = this;\n        // reject this promise after 15 seconds.\n        var requestId = ++this.requestId;\n        var removeRequest = function () { return delete _this.roomsAvailableRequests[requestId]; };\n        var rejectionTimeout = setTimeout(function () {\n            removeRequest();\n            callback([], 'timeout');\n        }, 15000);\n        // send the request to the server.\n        this.connection.send([Protocol_1.Protocol.ROOM_LIST, requestId, roomName]);\n        this.roomsAvailableRequests[requestId] = function (roomsAvailable) {\n            removeRequest();\n            clearTimeout(rejectionTimeout);\n            callback(roomsAvailable);\n        };\n    };\n    Client.prototype.close = function () {\n        this.connection.close();\n    };\n    Client.prototype.createRoom = function (roomName, options) {\n        if (options === void 0) { options = {}; }\n        return new Room_1.Room(roomName, options);\n    };\n    Client.prototype.createRoomRequest = function (roomName, options, reuseRoomInstance, retryCount) {\n        var _this = this;\n        options.requestId = ++this.requestId;\n        var room = reuseRoomInstance || this.createRoom(roomName, options);\n        // remove references on leaving\n        room.onLeave.addOnce(function () {\n            delete _this.rooms[room.id];\n            delete _this.connectingRooms[options.requestId];\n        });\n        //\n        // retry joining the room in case the server couldn't matchmake into it\n        //\n        // TODO: improve match-making routine https://github.com/gamestdio/colyseus/issues/176\n        //\n        if (options.retryTimes) {\n            room.onError.addOnce(function () {\n                retryCount = retryCount || 0;\n                if (!room.hasJoined && retryCount <= options.retryTimes) {\n                    retryCount++;\n                    _this.createRoomRequest(roomName, options, room, retryCount);\n                }\n            });\n        }\n        this.connectingRooms[options.requestId] = room;\n        this.connection.send([Protocol_1.Protocol.JOIN_REQUEST, roomName, options]);\n        return room;\n    };\n    Client.prototype.connect = function (colyseusid, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        this.id = colyseusid || '';\n        this.connection = new Connection_1.Connection(this.buildEndpoint('', options));\n        this.connection.onmessage = this.onMessageCallback.bind(this);\n        this.connection.onclose = function (e) { return _this.onClose.dispatch(e); };\n        this.connection.onerror = function (e) { return _this.onError.dispatch(e); };\n        // check for id on cookie\n        this.connection.onopen = function () {\n            if (_this.id) {\n                _this.onOpen.dispatch();\n            }\n        };\n    };\n    Client.prototype.buildEndpoint = function (path, options) {\n        if (path === void 0) { path = ''; }\n        if (options === void 0) { options = {}; }\n        // append colyseusid to connection string.\n        var params = [\"colyseusid=\" + this.id];\n        for (var name_1 in options) {\n            if (!options.hasOwnProperty(name_1)) {\n                continue;\n            }\n            params.push(name_1 + \"=\" + options[name_1]);\n        }\n        return this.hostname + \"/\" + path + \"?\" + params.join('&');\n    };\n    /**\n     * @override\n     */\n    Client.prototype.onMessageCallback = function (event) {\n        if (!this.previousCode) {\n            var view = new DataView(event.data);\n            var code = view.getUint8(0);\n            if (code === Protocol_1.Protocol.USER_ID) {\n                this.id = Protocol_1.utf8Read(view, 1);\n                Storage_1.setItem('colyseusid', this.id);\n                this.onOpen.dispatch();\n            }\n            else if (code === Protocol_1.Protocol.JOIN_REQUEST) {\n                var requestId = view.getUint8(1);\n                var room = this.connectingRooms[requestId];\n                if (!room) {\n                    console.warn('colyseus.js: client left room before receiving session id.');\n                    return;\n                }\n                room.id = Protocol_1.utf8Read(view, 2);\n                this.rooms[room.id] = room;\n                room.connect(this.buildEndpoint(room.id, room.options));\n                delete this.connectingRooms[requestId];\n            }\n            else if (code === Protocol_1.Protocol.JOIN_ERROR) {\n                var err = Protocol_1.utf8Read(view, 1);\n                console.error('colyseus.js: server error:', err);\n                // general error\n                this.onError.dispatch(err);\n            }\n            else if (code === Protocol_1.Protocol.ROOM_LIST) {\n                this.previousCode = code;\n            }\n        }\n        else {\n            if (this.previousCode === Protocol_1.Protocol.ROOM_LIST) {\n                var _a = msgpack.decode(new Uint8Array(event.data)), requestId = _a[0], rooms = _a[1];\n                if (this.roomsAvailableRequests[requestId]) {\n                    this.roomsAvailableRequests[requestId](rooms);\n                }\n                else {\n                    console.warn('receiving ROOM_LIST after timeout:', rooms);\n                }\n            }\n            this.previousCode = undefined;\n        }\n    };\n    return Client;\n}());\nexports.Client = Client;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/Client.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/Connection.js":
/*!****************************************************!*\
  !*** ./node_modules/colyseus.js/lib/Connection.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar websocket_1 = __webpack_require__(/*! @gamestdio/websocket */ \"./node_modules/@gamestdio/websocket/lib/index.js\");\nvar msgpack = __webpack_require__(/*! ./msgpack */ \"./node_modules/colyseus.js/lib/msgpack.js\");\nvar Connection = /** @class */ (function (_super) {\n    __extends(Connection, _super);\n    function Connection(url, autoConnect) {\n        if (autoConnect === void 0) { autoConnect = true; }\n        var _this = _super.call(this, url, undefined, { connect: autoConnect }) || this;\n        _this._enqueuedCalls = [];\n        return _this;\n    }\n    Connection.prototype.onOpenCallback = function (event) {\n        _super.prototype.onOpenCallback.call(this);\n        this.binaryType = 'arraybuffer';\n        if (this._enqueuedCalls.length > 0) {\n            for (var _i = 0, _a = this._enqueuedCalls; _i < _a.length; _i++) {\n                var _b = _a[_i], method = _b[0], args = _b[1];\n                this[method].apply(this, args);\n            }\n            // clear enqueued calls.\n            this._enqueuedCalls = [];\n        }\n    };\n    Connection.prototype.send = function (data) {\n        if (this.ws.readyState === websocket_1.default.OPEN) {\n            return _super.prototype.send.call(this, msgpack.encode(data));\n        }\n        else {\n            // WebSocket not connected.\n            // Enqueue data to be sent when readyState == OPEN\n            this._enqueuedCalls.push(['send', [data]]);\n        }\n    };\n    return Connection;\n}(websocket_1.default));\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/Connection.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/Protocol.js":
/*!**************************************************!*\
  !*** ./node_modules/colyseus.js/lib/Protocol.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Use codes between 0~127 for lesser throughput (1 byte)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Protocol;\n(function (Protocol) {\n    // User-related (0~8)\n    Protocol[Protocol[\"USER_ID\"] = 1] = \"USER_ID\";\n    // Room-related (9~19)\n    Protocol[Protocol[\"JOIN_REQUEST\"] = 9] = \"JOIN_REQUEST\";\n    Protocol[Protocol[\"JOIN_ROOM\"] = 10] = \"JOIN_ROOM\";\n    Protocol[Protocol[\"JOIN_ERROR\"] = 11] = \"JOIN_ERROR\";\n    Protocol[Protocol[\"LEAVE_ROOM\"] = 12] = \"LEAVE_ROOM\";\n    Protocol[Protocol[\"ROOM_DATA\"] = 13] = \"ROOM_DATA\";\n    Protocol[Protocol[\"ROOM_STATE\"] = 14] = \"ROOM_STATE\";\n    Protocol[Protocol[\"ROOM_STATE_PATCH\"] = 15] = \"ROOM_STATE_PATCH\";\n    // Match-making related (20~29)\n    Protocol[Protocol[\"ROOM_LIST\"] = 20] = \"ROOM_LIST\";\n    // Generic messages (50~60)\n    Protocol[Protocol[\"BAD_REQUEST\"] = 50] = \"BAD_REQUEST\";\n})(Protocol = exports.Protocol || (exports.Protocol = {}));\nfunction utf8Read(view, offset) {\n    var length = view.getUint8(offset++);\n    var string = '', chr = 0;\n    for (var i = offset, end = offset + length; i < end; i++) {\n        var byte = view.getUint8(i);\n        if ((byte & 0x80) === 0x00) {\n            string += String.fromCharCode(byte);\n            continue;\n        }\n        if ((byte & 0xe0) === 0xc0) {\n            string += String.fromCharCode(((byte & 0x1f) << 6) |\n                (view.getUint8(++i) & 0x3f));\n            continue;\n        }\n        if ((byte & 0xf0) === 0xe0) {\n            string += String.fromCharCode(((byte & 0x0f) << 12) |\n                ((view.getUint8(++i) & 0x3f) << 6) |\n                ((view.getUint8(++i) & 0x3f) << 0));\n            continue;\n        }\n        if ((byte & 0xf8) === 0xf0) {\n            chr = ((byte & 0x07) << 18) |\n                ((view.getUint8(++i) & 0x3f) << 12) |\n                ((view.getUint8(++i) & 0x3f) << 6) |\n                ((view.getUint8(++i) & 0x3f) << 0);\n            if (chr >= 0x010000) { // surrogate pair\n                chr -= 0x010000;\n                string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n            }\n            else {\n                string += String.fromCharCode(chr);\n            }\n            continue;\n        }\n        throw new Error('Invalid byte ' + byte.toString(16));\n    }\n    return string;\n}\nexports.utf8Read = utf8Read;\n// Faster for short strings than Buffer.byteLength\nfunction utf8Length(str) {\n    if (str === void 0) { str = ''; }\n    var c = 0;\n    var length = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length + 1;\n}\nexports.utf8Length = utf8Length;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/Protocol.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/Room.js":
/*!**********************************************!*\
  !*** ./node_modules/colyseus.js/lib/Room.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar signals_1 = __webpack_require__(/*! @gamestdio/signals */ \"./node_modules/@gamestdio/signals/lib/index.js\");\nvar msgpack = __webpack_require__(/*! ./msgpack */ \"./node_modules/colyseus.js/lib/msgpack.js\");\nvar Connection_1 = __webpack_require__(/*! ./Connection */ \"./node_modules/colyseus.js/lib/Connection.js\");\nvar Serializer_1 = __webpack_require__(/*! ./serializer/Serializer */ \"./node_modules/colyseus.js/lib/serializer/Serializer.js\");\nvar Protocol_1 = __webpack_require__(/*! ./Protocol */ \"./node_modules/colyseus.js/lib/Protocol.js\");\nvar FossilDeltaSerializer_1 = __webpack_require__(/*! ./serializer/FossilDeltaSerializer */ \"./node_modules/colyseus.js/lib/serializer/FossilDeltaSerializer.js\");\nvar Room = /** @class */ (function () {\n    function Room(name, options) {\n        var _this = this;\n        // Public signals\n        this.onJoin = new signals_1.Signal();\n        this.onStateChange = new signals_1.Signal();\n        this.onMessage = new signals_1.Signal();\n        this.onError = new signals_1.Signal();\n        this.onLeave = new signals_1.Signal();\n        this.id = null;\n        this.name = name;\n        this.options = options;\n        // TODO: remove default serializer. it should arrive only after JOIN_ROOM.\n        this.serializer = new FossilDeltaSerializer_1.FossilDeltaSerializer();\n        this.onLeave.add(function () { return _this.removeAllListeners(); });\n    }\n    Room.prototype.connect = function (endpoint) {\n        var _this = this;\n        this.connection = new Connection_1.Connection(endpoint, false);\n        this.connection.reconnectEnabled = false;\n        this.connection.onmessage = this.onMessageCallback.bind(this);\n        this.connection.onclose = function (e) { return _this.onLeave.dispatch(e); };\n        this.connection.onerror = function (e) {\n            console.warn(\"Possible causes: room's onAuth() failed or maxClients has been reached.\");\n            _this.onError.dispatch(e);\n        };\n        this.connection.open();\n    };\n    Room.prototype.leave = function (consented) {\n        if (consented === void 0) { consented = true; }\n        if (this.connection) {\n            if (consented) {\n                this.connection.send([Protocol_1.Protocol.LEAVE_ROOM]);\n            }\n            else {\n                this.connection.close();\n            }\n        }\n        else {\n            this.onLeave.dispatch();\n        }\n    };\n    Room.prototype.send = function (data) {\n        this.connection.send([Protocol_1.Protocol.ROOM_DATA, this.id, data]);\n    };\n    Object.defineProperty(Room.prototype, \"state\", {\n        get: function () {\n            return this.serializer.getState();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Room.prototype, \"hasJoined\", {\n        get: function () {\n            return this.sessionId !== undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // TODO: deprecate / move somewhere else\n    // this method is useful only for FossilDeltaSerializer\n    Room.prototype.listen = function (segments, callback, immediate) {\n        if (this.serializerId === \"schema\") {\n            console.error(\"'\" + this.serializerId + \"' serializer doesn't support .listen() method.\");\n            return;\n        }\n        else if (!this.serializerId) {\n            console.warn(\"room.Listen() should be called after room.onJoin has been called (DEPRECATION WARNING)\");\n        }\n        return this.serializer.api.listen(segments, callback, immediate);\n    };\n    // TODO: deprecate / move somewhere else\n    // this method is useful only for FossilDeltaSerializer\n    Room.prototype.removeListener = function (listener) {\n        return this.serializer.api.removeListener(listener);\n    };\n    Room.prototype.removeAllListeners = function () {\n        if (this.serializer) {\n            this.serializer.teardown();\n        }\n        this.onJoin.removeAll();\n        this.onStateChange.removeAll();\n        this.onMessage.removeAll();\n        this.onError.removeAll();\n        this.onLeave.removeAll();\n    };\n    Room.prototype.onMessageCallback = function (event) {\n        if (!this.previousCode) {\n            var view = new DataView(event.data);\n            var code = view.getUint8(0);\n            if (code === Protocol_1.Protocol.JOIN_ROOM) {\n                var offset = 1;\n                this.sessionId = Protocol_1.utf8Read(view, offset);\n                offset += Protocol_1.utf8Length(this.sessionId);\n                this.serializerId = Protocol_1.utf8Read(view, offset);\n                offset += Protocol_1.utf8Length(this.serializerId);\n                // get serializer implementation\n                var serializer = Serializer_1.getSerializer(this.serializerId);\n                if (!serializer) {\n                    throw new Error(\"missing serializer: \" + this.serializerId);\n                }\n                // TODO: remove this check\n                if (this.serializerId !== \"fossil-delta\") {\n                    this.serializer = new serializer();\n                }\n                if (view.buffer.byteLength > offset && this.serializer.handshake) {\n                    var bytes = Array.from(new Uint8Array(view.buffer.slice(offset)));\n                    this.serializer.handshake(bytes);\n                }\n                this.onJoin.dispatch();\n            }\n            else if (code === Protocol_1.Protocol.JOIN_ERROR) {\n                this.onError.dispatch(Protocol_1.utf8Read(view, 1));\n            }\n            else if (code === Protocol_1.Protocol.LEAVE_ROOM) {\n                this.leave();\n            }\n            else {\n                this.previousCode = code;\n            }\n        }\n        else {\n            if (this.previousCode === Protocol_1.Protocol.ROOM_STATE) {\n                // TODO: improve here!\n                this.setState(Array.from(new Uint8Array(event.data)));\n            }\n            else if (this.previousCode === Protocol_1.Protocol.ROOM_STATE_PATCH) {\n                this.patch(Array.from(new Uint8Array(event.data)));\n            }\n            else if (this.previousCode === Protocol_1.Protocol.ROOM_DATA) {\n                this.onMessage.dispatch(msgpack.decode(event.data));\n            }\n            this.previousCode = undefined;\n        }\n    };\n    Room.prototype.setState = function (encodedState) {\n        this.serializer.setState(encodedState);\n        this.onStateChange.dispatch(this.serializer.getState());\n    };\n    Room.prototype.patch = function (binaryPatch) {\n        this.serializer.patch(binaryPatch);\n        this.onStateChange.dispatch(this.serializer.getState());\n    };\n    return Room;\n}());\nexports.Room = Room;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/Room.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/Storage.js":
/*!*************************************************!*\
  !*** ./node_modules/colyseus.js/lib/Storage.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * We do not assign 'storage' to window.localStorage immediatelly for React\n * Native compatibility. window.localStorage is not present when this module is\n * loaded.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar storage;\nfunction getStorage() {\n    if (!storage) {\n        storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)\n            ? cc.sys.localStorage // compatibility with cocos creator\n            : typeof (window) !== \"undefined\"\n                ? window.localStorage // regular browser environment\n                : {\n                    cache: {},\n                    setItem: function (key, value) { this.cache[key] = value; },\n                    getItem: function (key) { this.cache[key]; },\n                };\n    }\n    return storage;\n}\nfunction setItem(key, value) {\n    getStorage().setItem(key, value);\n}\nexports.setItem = setItem;\nfunction getItem(key, callback) {\n    var value = getStorage().getItem(key);\n    if (typeof (Promise) === 'undefined' || // old browsers\n        !(value instanceof Promise)) {\n        // browser has synchronous return\n        callback(value);\n    }\n    else {\n        // react-native is asynchronous\n        value.then(function (id) { return callback(id); });\n    }\n}\nexports.getItem = getItem;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/Storage.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/colyseus.js/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! ./legacy */ \"./node_modules/colyseus.js/lib/legacy.js\");\nvar Client_1 = __webpack_require__(/*! ./Client */ \"./node_modules/colyseus.js/lib/Client.js\");\nexports.Client = Client_1.Client;\nvar Protocol_1 = __webpack_require__(/*! ./Protocol */ \"./node_modules/colyseus.js/lib/Protocol.js\");\nexports.Protocol = Protocol_1.Protocol;\nvar Room_1 = __webpack_require__(/*! ./Room */ \"./node_modules/colyseus.js/lib/Room.js\");\nexports.Room = Room_1.Room;\n/*\n * Serializers\n */\nvar FossilDeltaSerializer_1 = __webpack_require__(/*! ./serializer/FossilDeltaSerializer */ \"./node_modules/colyseus.js/lib/serializer/FossilDeltaSerializer.js\");\nexports.FossilDeltaSerializer = FossilDeltaSerializer_1.FossilDeltaSerializer;\nvar SchemaSerializer_1 = __webpack_require__(/*! ./serializer/SchemaSerializer */ \"./node_modules/colyseus.js/lib/serializer/SchemaSerializer.js\");\nexports.SchemaSerializer = SchemaSerializer_1.SchemaSerializer;\nvar Serializer_1 = __webpack_require__(/*! ./serializer/Serializer */ \"./node_modules/colyseus.js/lib/serializer/Serializer.js\");\nexports.registerSerializer = Serializer_1.registerSerializer;\nvar schema_1 = __webpack_require__(/*! @colyseus/schema */ \"./node_modules/@colyseus/schema/lib/index.js\");\nexports.Schema = schema_1.Schema;\nexports.type = schema_1.type;\nSerializer_1.registerSerializer('fossil-delta', FossilDeltaSerializer_1.FossilDeltaSerializer);\nSerializer_1.registerSerializer('schema', SchemaSerializer_1.SchemaSerializer);\n/**\n * Experimental sync helpers\n */\nvar helpers_1 = __webpack_require__(/*! ./sync/helpers */ \"./node_modules/colyseus.js/lib/sync/helpers.js\");\nexports.initializeSync = helpers_1.initializeSync;\nexports.sync = helpers_1.sync;\nexports.syncMap = helpers_1.syncMap;\nexports.syncObject = helpers_1.syncObject;\nexports.syncVar = helpers_1.syncVar;\nexports.syncList = helpers_1.syncList;\nexports.key = helpers_1.key;\nexports.room = helpers_1.room;\nexports.listen = helpers_1.listen;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/index.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/legacy.js":
/*!************************************************!*\
  !*** ./node_modules/colyseus.js/lib/legacy.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//\n// Polyfills for legacy environments\n//\n/*\n * Support Android 4.4.x\n */\nif (!ArrayBuffer.isView) {\n    ArrayBuffer.isView = function (a) {\n        return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/legacy.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/msgpack.js":
/*!*************************************************!*\
  !*** ./node_modules/colyseus.js/lib/msgpack.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar msgpackDecode = __webpack_require__(/*! notepack.io/browser/decode */ \"./node_modules/notepack.io/browser/decode.js\");\nvar msgpackEncode = __webpack_require__(/*! notepack.io/browser/encode */ \"./node_modules/notepack.io/browser/encode.js\");\nexports.decode = msgpackDecode;\nexports.encode = msgpackEncode;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/msgpack.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/serializer/FossilDeltaSerializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/colyseus.js/lib/serializer/FossilDeltaSerializer.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar state_listener_1 = __webpack_require__(/*! @gamestdio/state-listener */ \"./node_modules/@gamestdio/state-listener/lib/index.js\");\nvar fossilDelta = __webpack_require__(/*! fossil-delta */ \"./node_modules/fossil-delta/fossil-delta.js\");\nvar msgpack = __webpack_require__(/*! ../msgpack */ \"./node_modules/colyseus.js/lib/msgpack.js\");\nvar FossilDeltaSerializer = /** @class */ (function () {\n    function FossilDeltaSerializer() {\n        this.api = new state_listener_1.StateContainer({});\n    }\n    FossilDeltaSerializer.prototype.getState = function () {\n        return this.api.state;\n    };\n    FossilDeltaSerializer.prototype.setState = function (encodedState) {\n        this.previousState = new Uint8Array(encodedState);\n        this.api.set(msgpack.decode(this.previousState));\n    };\n    FossilDeltaSerializer.prototype.patch = function (binaryPatch) {\n        // apply patch\n        this.previousState = new Uint8Array(fossilDelta.apply(this.previousState, binaryPatch));\n        // trigger update callbacks\n        this.api.set(msgpack.decode(this.previousState));\n    };\n    FossilDeltaSerializer.prototype.teardown = function () {\n        this.api.removeAllListeners();\n    };\n    return FossilDeltaSerializer;\n}());\nexports.FossilDeltaSerializer = FossilDeltaSerializer;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/serializer/FossilDeltaSerializer.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/serializer/SchemaSerializer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/colyseus.js/lib/serializer/SchemaSerializer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar schema_1 = __webpack_require__(/*! @colyseus/schema */ \"./node_modules/@colyseus/schema/lib/index.js\");\nvar SchemaSerializer = /** @class */ (function () {\n    function SchemaSerializer() {\n    }\n    SchemaSerializer.prototype.setState = function (rawState) {\n        this.state.decode(rawState);\n    };\n    SchemaSerializer.prototype.getState = function () {\n        return this.state;\n    };\n    SchemaSerializer.prototype.patch = function (patches) {\n        this.state.decode(patches);\n    };\n    SchemaSerializer.prototype.teardown = function () {\n        // this.state.onRemove\n    };\n    SchemaSerializer.prototype.handshake = function (bytes) {\n        this.state = schema_1.Reflection.decode(bytes);\n    };\n    return SchemaSerializer;\n}());\nexports.SchemaSerializer = SchemaSerializer;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/serializer/SchemaSerializer.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/serializer/Serializer.js":
/*!***************************************************************!*\
  !*** ./node_modules/colyseus.js/lib/serializer/Serializer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar serializers = {};\nfunction registerSerializer(id, serializer) {\n    serializers[id] = serializer;\n}\nexports.registerSerializer = registerSerializer;\nfunction getSerializer(id) {\n    return serializers[id];\n}\nexports.getSerializer = getSerializer;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/serializer/Serializer.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/sync/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/colyseus.js/lib/sync/helpers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar listeners = __webpack_require__(/*! ./listeners */ \"./node_modules/colyseus.js/lib/sync/listeners.js\");\nfunction initializeSync(roomInstance, synchable) {\n    createBindings(roomInstance, synchable, synchable);\n}\nexports.initializeSync = initializeSync;\nfunction syncMap(type, addCallback, removeCallback) {\n    return sync(type, 'map', addCallback, removeCallback);\n}\nexports.syncMap = syncMap;\nfunction syncObject(type, addCallback, removeCallback) {\n    return sync(type, 'object', addCallback, removeCallback);\n}\nexports.syncObject = syncObject;\nfunction syncVar(type, addCallback, removeCallback) {\n    return sync(type, 'var');\n}\nexports.syncVar = syncVar;\nfunction syncList(type, addCallback, removeCallback) {\n    return sync(type, 'list', addCallback, removeCallback);\n}\nexports.syncList = syncList;\nfunction key() {\n    return sync(undefined, 'key');\n}\nexports.key = key;\nfunction room() {\n    return function (proto, attr) {\n        Object.defineProperty(proto, attr, {\n            configurable: true,\n            enumerable: true,\n            get: function () { return proto.constructor.$room; },\n        });\n    };\n}\nexports.room = room;\nfunction sync(type, holderType, addCallback, removeCallback) {\n    if (holderType === void 0) { holderType = 'var'; }\n    return function (target, propertyKey) {\n        if (!target.constructor.properties) {\n            target.constructor.properties = {};\n        }\n        var variable = propertyKey;\n        if (typeof (type) === 'string') {\n            variable = propertyKey;\n            propertyKey = type;\n            type = undefined;\n        }\n        target.constructor.properties[propertyKey] = {\n            addCallback: addCallback,\n            holderType: holderType,\n            removeCallback: removeCallback,\n            type: type,\n            variable: variable,\n        };\n    };\n}\nexports.sync = sync;\nfunction listen(path, op) {\n    return function (target, methodName, descriptor) {\n        if (!target.constructor.listeners) {\n            target.constructor.listeners = {};\n        }\n        target.constructor.listeners[path] = { methodName: methodName, op: op };\n    };\n}\nexports.listen = listen;\nvar listenersMap = {};\nfunction createBindings(roomInstance, synchable, synchableRoot, parentSegment) {\n    bindProperties(synchable.constructor.properties || synchable.properties, roomInstance, synchable, synchableRoot, parentSegment);\n    bindListeners(synchable.constructor.listeners, roomInstance, synchable);\n}\nexports.createBindings = createBindings;\nfunction bindProperties(properties, roomInstance, synchable, synchableRoot, parentSegment) {\n    // no properties to sync\n    if (!properties) {\n        return;\n    }\n    // room reference\n    Object.defineProperty(synchable, '$room', {\n        configurable: true,\n        enumerable: false,\n        value: roomInstance,\n        writable: true,\n    });\n    synchable.$room = roomInstance;\n    // create bindings for properties\n    for (var segment in properties) {\n        if (!properties.hasOwnProperty(segment)) {\n            continue;\n        }\n        var property = properties[segment];\n        var path = (parentSegment)\n            ? parentSegment + \"/\" + segment\n            : segment;\n        if (property.holderType === 'map') {\n            path += '/:id';\n        }\n        // skip if duplicate listenersMap\n        if (listenersMap[path]) {\n            return;\n        }\n        else {\n            listenersMap[path] = true;\n        }\n        var listener = listeners[property.holderType + \"Listener\"];\n        if (listener) {\n            roomInstance.listen(path, listener(roomInstance, property, synchable, synchableRoot, path));\n            if (property.type) {\n                createBindings(roomInstance, property.type, synchable, path);\n            }\n        }\n    }\n}\nfunction bindListeners(listenersToBind, roomInstance, synchable) {\n    if (!listenersToBind) {\n        return;\n    }\n    var _loop_1 = function (path) {\n        if (!listenersToBind.hasOwnProperty(path)) {\n            return \"continue\";\n        }\n        var listener = listenersToBind[path];\n        var callback = (listener.op)\n            ? (function (change) {\n                if (change.operation === listener.op) {\n                    synchable[listener.methodName](change);\n                }\n            })\n            : synchable[listener.methodName].bind(synchable);\n        roomInstance.listen(path, callback);\n    };\n    for (var path in listenersToBind) {\n        _loop_1(path);\n    }\n}\nexports.bindListeners = bindListeners;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/sync/helpers.js?");

/***/ }),

/***/ "./node_modules/colyseus.js/lib/sync/listeners.js":
/*!********************************************************!*\
  !*** ./node_modules/colyseus.js/lib/sync/listeners.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/colyseus.js/lib/sync/helpers.js\");\nfunction assign(instance, property, propName, value, key) {\n    if (property.holderType === 'var') {\n        instance[propName] = value;\n    }\n    else if (property.holderType === 'key') {\n        // mapListener only\n        instance[propName] = key;\n    }\n}\nfunction assignMultiple(instance, properties, value, key) {\n    for (var prop in properties) {\n        if (!properties.hasOwnProperty(prop)) {\n            continue;\n        }\n        assign(instance, properties[prop], prop, value[prop], key);\n    }\n}\nfunction getInstanceContainer(root, path, offset) {\n    if (offset === void 0) { offset = 0; }\n    var instance = root;\n    for (var i = 0, len = path.length; i < len + offset; i++) {\n        if (typeof (instance[path[i]]) !== 'object') {\n            break;\n        }\n        instance = instance[path[i]];\n    }\n    return instance;\n}\nfunction objectListener(room, property, synchable, synchableRoot, parentSegment) {\n    return function (change) {\n        if (change.operation === 'add') {\n            var newType = new property.type();\n            // assign all variables to new instance type\n            for (var prop in change.value) {\n                if (!change.value.hasOwnProperty(prop)) {\n                    continue;\n                }\n                newType[prop] = change.value[prop];\n            }\n            // bind @listen annotations\n            helpers_1.bindListeners(property.type.listeners, room, newType);\n            synchable[property.variable] = newType;\n            if (property.addCallback) {\n                property.addCallback.call(synchableRoot, synchableRoot, newType, change);\n            }\n        }\n        else if (change.operation === 'replace') {\n            synchableRoot[this.rawRules[0]][property.variable] = change.value;\n        }\n        else if (change.operation === 'remove') {\n            if (property.removeCallback) {\n                property.removeCallback.call(synchableRoot, synchableRoot, synchable[property.variable][change.path.id], change);\n            }\n            delete synchable[property.variable];\n        }\n    };\n}\nexports.objectListener = objectListener;\nfunction mapListener(room, property, synchable, synchableRoot, parentSegment) {\n    return function (change) {\n        var instance = getInstanceContainer(synchableRoot, change.rawPath);\n        if (change.operation === 'add') {\n            var newType = new property.type();\n            // define __mapParent as non-enumerable.\n            Object.defineProperty(newType, '__mapParent', {\n                configurable: true,\n                enumerable: false,\n                value: getInstanceContainer(synchableRoot, change.rawPath, -2),\n                writable: true,\n            });\n            // bind @listen annotations\n            helpers_1.bindListeners(property.type.listeners, room, newType);\n            instance[change.path.id] = newType;\n            // assign all variables to new instance type\n            assignMultiple(newType, property.type.properties, change.value, change.path.id);\n            if (property.addCallback) {\n                property.addCallback.call(newType.__mapParent, newType.__mapParent, newType, change);\n            }\n        }\n        else if (change.operation === 'replace') {\n            assign(instance, property, property.variable, change.value);\n        }\n        else if (change.operation === 'remove') {\n            if (property.removeCallback) {\n                property.removeCallback.call(instance.__mapParent, instance.__mapParent, instance, change);\n            }\n            delete synchable[property.variable][change.path.id];\n        }\n    };\n}\nexports.mapListener = mapListener;\nfunction varListener(room, property, synchable, synchableRoot, parentSegment) {\n    return function (change) {\n        var target = getInstanceContainer(synchableRoot, change.rawPath);\n        if (change.operation !== 'remove') {\n            assign(target, property, property.variable, change.value);\n        }\n        else if (change.operation === 'remove') {\n            delete target[property.variable];\n        }\n    };\n}\nexports.varListener = varListener;\n\n\n//# sourceURL=webpack:///./node_modules/colyseus.js/lib/sync/listeners.js?");

/***/ }),

/***/ "./node_modules/fossil-delta/fossil-delta.js":
/*!***************************************************!*\
  !*** ./node_modules/fossil-delta/fossil-delta.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Fossil SCM delta compression algorithm\n// ======================================\n//\n// Format:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_format.wiki\n//\n// Algorithm:\n// http://www.fossil-scm.org/index.html/doc/tip/www/delta_encoder_algorithm.wiki\n//\n// Original implementation:\n// http://www.fossil-scm.org/index.html/artifact/d1b0598adcd650b3551f63b17dfc864e73775c3d\n//\n// LICENSE\n// -------\n//\n// Copyright 2014 Dmitry Chestnykh (JavaScript port)\n// Copyright 2007 D. Richard Hipp  (original C version)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or\n// without modification, are permitted provided that the\n// following conditions are met:\n//\n//   1. Redistributions of source code must retain the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer.\n//\n//   2. Redistributions in binary form must reproduce the above\n//      copyright notice, this list of conditions and the\n//      following disclaimer in the documentation and/or other\n//      materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// The views and conclusions contained in the software and documentation\n// are those of the authors and contributors and should not be interpreted\n// as representing official policies, either expressed or implied, of anybody\n// else.\n//\n(function(root, factory) {\n  if ( true && module.exports) module.exports = factory();\n  else root.fossilDelta = factory();\n})(this, function() {\n'use strict';\n\nvar fossilDelta = {};\n\n// Hash window width in bytes. Must be a power of two.\nvar NHASH = 16;\n\nfunction RollingHash() {\n  this.a = 0; // hash     (16-bit unsigned)\n  this.b = 0; // values   (16-bit unsigned)\n  this.i = 0; // start of the hash window (16-bit unsigned)\n  this.z = new Array(NHASH); // the values that have been hashed.\n}\n\n// Initialize the rolling hash using the first NHASH bytes of\n// z at the given position.\nRollingHash.prototype.init = function(z, pos) {\n  var a = 0, b = 0, i, x;\n  for(i = 0; i < NHASH; i++){\n    x = z[pos+i];\n    a = (a + x) & 0xffff;\n    b = (b + (NHASH-i)*x) & 0xffff;\n    this.z[i] = x;\n  }\n  this.a = a & 0xffff;\n  this.b = b & 0xffff;\n  this.i = 0;\n};\n\n// Advance the rolling hash by a single byte \"c\".\nRollingHash.prototype.next = function(c) {\n  var old = this.z[this.i];\n  this.z[this.i] = c;\n  this.i = (this.i+1)&(NHASH-1);\n  this.a = (this.a - old + c) & 0xffff;\n  this.b = (this.b - NHASH*old + this.a) & 0xffff;\n};\n\n// Return a 32-bit hash value.\nRollingHash.prototype.value = function() {\n  return ((this.a & 0xffff) | (this.b & 0xffff)<<16)>>>0;\n};\n\nvar zDigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\".\n                split('').map(function (x) { return x.charCodeAt(0); });\n\nvar zValue = [\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,\n  25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,\n  -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,\n  52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1\n];\n\n// Reader reads bytes, chars, ints from array.\nfunction Reader(array) {\n  this.a = array; // source array\n  this.pos = 0;   // current position in array\n}\n\nReader.prototype.haveBytes = function() {\n  return this.pos < this.a.length;\n};\n\nReader.prototype.getByte = function() {\n  var b = this.a[this.pos];\n  this.pos++;\n  if (this.pos > this.a.length) throw new RangeError('out of bounds');\n  return b;\n};\n\nReader.prototype.getChar = function() {\n  return String.fromCharCode(this.getByte());\n};\n\n// Read base64-encoded unsigned integer.\nReader.prototype.getInt = function(){\n  var v = 0, c;\n  while(this.haveBytes() && (c = zValue[0x7f & this.getByte()]) >= 0) {\n     v = (v<<6) + c;\n  }\n  this.pos--;\n  return v >>> 0;\n};\n\n\n// Write writes an array.\nfunction Writer() {\n  this.a = [];\n}\n\nWriter.prototype.toArray = function() {\n  return this.a;\n};\n\nWriter.prototype.putByte = function(b) {\n  this.a.push(b & 0xff);\n};\n\n// Write an ASCII character (s is a one-char string).\nWriter.prototype.putChar = function(s) {\n  this.putByte(s.charCodeAt(0));\n};\n\n// Write a base64 unsigned integer.\nWriter.prototype.putInt = function(v){\n  var i, j, zBuf = [];\n  if (v === 0) {\n    this.putChar('0');\n    return;\n  }\n  for (i = 0; v > 0; i++, v >>>= 6)\n    zBuf.push(zDigits[v&0x3f]);\n  for (j = i-1; j >= 0; j--)\n    this.putByte(zBuf[j]);\n};\n\n// Copy from array at start to end.\nWriter.prototype.putArray = function(a, start, end) {\n  for (var i = start; i < end; i++) this.a.push(a[i]);\n};\n\n// Return the number digits in the base64 representation of a positive integer.\nfunction digitCount(v){\n  var i, x;\n  for (i = 1, x = 64; v >= x; i++, x <<= 6){ /* nothing */ }\n  return i;\n}\n\n// Return a 32-bit checksum of the array.\nfunction checksum(arr) {\n  var sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0,\n      z = 0, N = arr.length;\n  //TODO measure if this unrolling is helpful.\n  while (N >= 16) {\n    sum0 = sum0 + arr[z+0] | 0;\n    sum1 = sum1 + arr[z+1] | 0;\n    sum2 = sum2 + arr[z+2] | 0;\n    sum3 = sum3 + arr[z+3] | 0;\n\n    sum0 = sum0 + arr[z+4] | 0;\n    sum1 = sum1 + arr[z+5] | 0;\n    sum2 = sum2 + arr[z+6] | 0;\n    sum3 = sum3 + arr[z+7] | 0;\n\n    sum0 = sum0 + arr[z+8] | 0;\n    sum1 = sum1 + arr[z+9] | 0;\n    sum2 = sum2 + arr[z+10] | 0;\n    sum3 = sum3 + arr[z+11] | 0;\n\n    sum0 = sum0 + arr[z+12] | 0;\n    sum1 = sum1 + arr[z+13] | 0;\n    sum2 = sum2 + arr[z+14] | 0;\n    sum3 = sum3 + arr[z+15] | 0;\n\n    z += 16;\n    N -= 16;\n  }\n  while (N >= 4) {\n    sum0 = sum0 + arr[z+0] | 0;\n    sum1 = sum1 + arr[z+1] | 0;\n    sum2 = sum2 + arr[z+2] | 0;\n    sum3 = sum3 + arr[z+3] | 0;\n    z += 4;\n    N -= 4;\n  }\n  sum3 = (((sum3 + (sum2 << 8) | 0) + (sum1 << 16) | 0) + (sum0 << 24) | 0);\n  /* jshint -W086 */\n  switch (N) {\n    case 3: sum3 = sum3 + (arr[z+2] <<  8) | 0; /* falls through */\n    case 2: sum3 = sum3 + (arr[z+1] << 16) | 0; /* falls through */\n    case 1: sum3 = sum3 + (arr[z+0] << 24) | 0; /* falls through */\n  }\n  return sum3 >>> 0;\n}\n\n// Create a new delta from src to out.\nfossilDelta.create = function(src, out) {\n  var zDelta = new Writer();\n  var lenOut = out.length;\n  var lenSrc = src.length;\n  var i, lastRead = -1;\n\n  zDelta.putInt(lenOut);\n  zDelta.putChar('\\n');\n\n  // If the source is very small, it means that we have no\n  // chance of ever doing a copy command.  Just output a single\n  // literal segment for the entire target and exit.\n  if (lenSrc <= NHASH) {\n    zDelta.putInt(lenOut);\n    zDelta.putChar(':');\n    zDelta.putArray(out, 0, lenOut);\n    zDelta.putInt(checksum(out));\n    zDelta.putChar(';');\n    return zDelta.toArray();\n  }\n\n  // Compute the hash table used to locate matching sections in the source.\n  var nHash = Math.ceil(lenSrc / NHASH);\n  var collide =  new Array(nHash);\n  var landmark = new Array(nHash);\n  for (i = 0; i < collide.length; i++) collide[i] = -1;\n  for (i = 0; i < landmark.length; i++) landmark[i] = -1;\n  var hv, h = new RollingHash();\n  for (i = 0; i < lenSrc-NHASH; i += NHASH) {\n    h.init(src, i);\n    hv = h.value() % nHash;\n    collide[i/NHASH] = landmark[hv];\n    landmark[hv] = i/NHASH;\n  }\n\n  var base = 0;\n  var iSrc, iBlock, bestCnt, bestOfst, bestLitsz;\n  while (base+NHASH<lenOut) {\n    bestOfst=0;\n    bestLitsz=0;\n    h.init(out, base);\n    i = 0; // Trying to match a landmark against zOut[base+i]\n    bestCnt = 0;\n    while(1) {\n      var limit = 250;\n      hv = h.value() % nHash;\n      iBlock = landmark[hv];\n      while (iBlock >= 0 && (limit--)>0 ) {\n        //\n        // The hash window has identified a potential match against\n        // landmark block iBlock.  But we need to investigate further.\n        //\n        // Look for a region in zOut that matches zSrc. Anchor the search\n        // at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to\n        // zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].\n        //\n        // Set cnt equal to the length of the match and set ofst so that\n        // zSrc[ofst] is the first element of the match.  litsz is the number\n        // of characters between zOut[base] and the beginning of the match.\n        // sz will be the overhead (in bytes) needed to encode the copy\n        // command.  Only generate copy command if the overhead of the\n        // copy command is less than the amount of literal text to be copied.\n        //\n        var cnt, ofst, litsz;\n        var j, k, x, y;\n        var sz;\n\n        // Beginning at iSrc, match forwards as far as we can.\n        // j counts the number of characters that match.\n        iSrc = iBlock*NHASH;\n        for (j = 0, x = iSrc, y = base+i; x < lenSrc && y < lenOut; j++, x++, y++) {\n          if (src[x] !== out[y]) break;\n        }\n        j--;\n\n        // Beginning at iSrc-1, match backwards as far as we can.\n        // k counts the number of characters that match.\n        for (k = 1; k < iSrc && k <= i; k++) {\n          if (src[iSrc-k] !== out[base+i-k]) break;\n        }\n        k--;\n\n        // Compute the offset and size of the matching region.\n        ofst = iSrc-k;\n        cnt = j+k+1;\n        litsz = i-k;  // Number of bytes of literal text before the copy\n        // sz will hold the number of bytes needed to encode the \"insert\"\n        // command and the copy command, not counting the \"insert\" text.\n        sz = digitCount(i-k)+digitCount(cnt)+digitCount(ofst)+3;\n        if (cnt >= sz && cnt > bestCnt) {\n          // Remember this match only if it is the best so far and it\n          // does not increase the file size.\n          bestCnt = cnt;\n          bestOfst = iSrc-k;\n          bestLitsz = litsz;\n        }\n\n        // Check the next matching block\n        iBlock = collide[iBlock];\n      }\n\n      // We have a copy command that does not cause the delta to be larger\n      // than a literal insert.  So add the copy command to the delta.\n      if (bestCnt > 0) {\n        if (bestLitsz > 0) {\n          // Add an insert command before the copy.\n          zDelta.putInt(bestLitsz);\n          zDelta.putChar(':');\n          zDelta.putArray(out, base, base+bestLitsz);\n          base += bestLitsz;\n        }\n        base += bestCnt;\n        zDelta.putInt(bestCnt);\n        zDelta.putChar('@');\n        zDelta.putInt(bestOfst);\n        zDelta.putChar(',');\n        if (bestOfst + bestCnt -1 > lastRead) {\n          lastRead = bestOfst + bestCnt - 1;\n        }\n        bestCnt = 0;\n        break;\n      }\n\n      // If we reach this point, it means no match is found so far\n      if (base+i+NHASH >= lenOut){\n        // We have reached the end and have not found any\n        // matches.  Do an \"insert\" for everything that does not match\n        zDelta.putInt(lenOut-base);\n        zDelta.putChar(':');\n        zDelta.putArray(out, base, base+lenOut-base);\n        base = lenOut;\n        break;\n      }\n\n      // Advance the hash by one character. Keep looking for a match.\n      h.next(out[base+i+NHASH]);\n      i++;\n    }\n  }\n  // Output a final \"insert\" record to get all the text at the end of\n  // the file that does not match anything in the source.\n  if(base < lenOut) {\n    zDelta.putInt(lenOut-base);\n    zDelta.putChar(':');\n    zDelta.putArray(out, base, base+lenOut-base);\n  }\n  // Output the final checksum record.\n  zDelta.putInt(checksum(out));\n  zDelta.putChar(';');\n  return zDelta.toArray();\n};\n\n// Return the size (in bytes) of the output from applying a delta.\nfossilDelta.outputSize = function(delta){\n  var zDelta = new Reader(delta);\n  var size = zDelta.getInt();\n  if (zDelta.getChar() !== '\\n')\n    throw new Error('size integer not terminated by \\'\\\\n\\'');\n  return size;\n};\n\n// Apply a delta.\nfossilDelta.apply = function(src, delta, opts) {\n  var limit, total = 0;\n  var zDelta = new Reader(delta);\n  var lenSrc = src.length;\n  var lenDelta = delta.length;\n\n  limit = zDelta.getInt();\n  if (zDelta.getChar() !== '\\n')\n    throw new Error('size integer not terminated by \\'\\\\n\\'');\n  var zOut = new Writer();\n  while(zDelta.haveBytes()) {\n    var cnt, ofst;\n    cnt = zDelta.getInt();\n\n    switch (zDelta.getChar()) {\n      case '@':\n        ofst = zDelta.getInt();\n        if (zDelta.haveBytes() && zDelta.getChar() !== ',')\n          throw new Error('copy command not terminated by \\',\\'');\n        total += cnt;\n        if (total > limit)\n          throw new Error('copy exceeds output file size');\n        if (ofst+cnt > lenSrc)\n          throw new Error('copy extends past end of input');\n        zOut.putArray(src, ofst, ofst+cnt);\n        break;\n\n      case ':':\n        total += cnt;\n        if (total > limit)\n          throw new Error('insert command gives an output larger than predicted');\n        if (cnt > lenDelta)\n          throw new Error('insert count exceeds size of delta');\n        zOut.putArray(zDelta.a, zDelta.pos, zDelta.pos+cnt);\n        zDelta.pos += cnt;\n        break;\n\n      case ';':\n        var out = zOut.toArray();\n        if ((!opts || opts.verifyChecksum !== false) && cnt !== checksum(out))\n          throw new Error('bad checksum');\n        if (total !== limit)\n          throw new Error('generated size does not match predicted size');\n        return out;\n\n      default:\n        throw new Error('unknown delta operator');\n    }\n  }\n  throw new Error('unterminated delta');\n};\n\nreturn fossilDelta;\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/fossil-delta/fossil-delta.js?");

/***/ }),

/***/ "./node_modules/notepack.io/browser/decode.js":
/*!****************************************************!*\
  !*** ./node_modules/notepack.io/browser/decode.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Decoder(buffer) {\n  this._offset = 0;\n  if (buffer instanceof ArrayBuffer) {\n    this._buffer = buffer;\n    this._view = new DataView(this._buffer);\n  } else if (ArrayBuffer.isView(buffer)) {\n    this._buffer = buffer.buffer;\n    this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);\n  } else {\n    throw new Error('Invalid argument');\n  }\n}\n\nfunction utf8Read(view, offset, length) {\n  var string = '', chr = 0;\n  for (var i = offset, end = offset + length; i < end; i++) {\n    var byte = view.getUint8(i);\n    if ((byte & 0x80) === 0x00) {\n      string += String.fromCharCode(byte);\n      continue;\n    }\n    if ((byte & 0xe0) === 0xc0) {\n      string += String.fromCharCode(\n        ((byte & 0x1f) << 6) |\n        (view.getUint8(++i) & 0x3f)\n      );\n      continue;\n    }\n    if ((byte & 0xf0) === 0xe0) {\n      string += String.fromCharCode(\n        ((byte & 0x0f) << 12) |\n        ((view.getUint8(++i) & 0x3f) << 6) |\n        ((view.getUint8(++i) & 0x3f) << 0)\n      );\n      continue;\n    }\n    if ((byte & 0xf8) === 0xf0) {\n      chr = ((byte & 0x07) << 18) |\n        ((view.getUint8(++i) & 0x3f) << 12) |\n        ((view.getUint8(++i) & 0x3f) << 6) |\n        ((view.getUint8(++i) & 0x3f) << 0);\n      if (chr >= 0x010000) { // surrogate pair\n        chr -= 0x010000;\n        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n      } else {\n        string += String.fromCharCode(chr);\n      }\n      continue;\n    }\n    throw new Error('Invalid byte ' + byte.toString(16));\n  }\n  return string;\n}\n\nDecoder.prototype._array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this._parse();\n  }\n  return value;\n};\n\nDecoder.prototype._map = function (length) {\n  var key = '', value = {};\n  for (var i = 0; i < length; i++) {\n    key = this._parse();\n    value[key] = this._parse();\n  }\n  return value;\n};\n\nDecoder.prototype._str = function (length) {\n  var value = utf8Read(this._view, this._offset, length);\n  this._offset += length;\n  return value;\n};\n\nDecoder.prototype._bin = function (length) {\n  var value = this._buffer.slice(this._offset, this._offset + length);\n  this._offset += length;\n  return value;\n};\n\nDecoder.prototype._parse = function () {\n  var prefix = this._view.getUint8(this._offset++);\n  var value, length = 0, type = 0, hi = 0, lo = 0;\n\n  if (prefix < 0xc0) {\n    // positive fixint\n    if (prefix < 0x80) {\n      return prefix;\n    }\n    // fixmap\n    if (prefix < 0x90) {\n      return this._map(prefix & 0x0f);\n    }\n    // fixarray\n    if (prefix < 0xa0) {\n      return this._array(prefix & 0x0f);\n    }\n    // fixstr\n    return this._str(prefix & 0x1f);\n  }\n\n  // negative fixint\n  if (prefix > 0xdf) {\n    return (0xff - prefix + 1) * -1;\n  }\n\n  switch (prefix) {\n    // nil\n    case 0xc0:\n      return null;\n    // false\n    case 0xc2:\n      return false;\n    // true\n    case 0xc3:\n      return true;\n\n    // bin\n    case 0xc4:\n      length = this._view.getUint8(this._offset);\n      this._offset += 1;\n      return this._bin(length);\n    case 0xc5:\n      length = this._view.getUint16(this._offset);\n      this._offset += 2;\n      return this._bin(length);\n    case 0xc6:\n      length = this._view.getUint32(this._offset);\n      this._offset += 4;\n      return this._bin(length);\n\n    // ext\n    case 0xc7:\n      length = this._view.getUint8(this._offset);\n      type = this._view.getInt8(this._offset + 1);\n      this._offset += 2;\n      return [type, this._bin(length)];\n    case 0xc8:\n      length = this._view.getUint16(this._offset);\n      type = this._view.getInt8(this._offset + 2);\n      this._offset += 3;\n      return [type, this._bin(length)];\n    case 0xc9:\n      length = this._view.getUint32(this._offset);\n      type = this._view.getInt8(this._offset + 4);\n      this._offset += 5;\n      return [type, this._bin(length)];\n\n    // float\n    case 0xca:\n      value = this._view.getFloat32(this._offset);\n      this._offset += 4;\n      return value;\n    case 0xcb:\n      value = this._view.getFloat64(this._offset);\n      this._offset += 8;\n      return value;\n\n    // uint\n    case 0xcc:\n      value = this._view.getUint8(this._offset);\n      this._offset += 1;\n      return value;\n    case 0xcd:\n      value = this._view.getUint16(this._offset);\n      this._offset += 2;\n      return value;\n    case 0xce:\n      value = this._view.getUint32(this._offset);\n      this._offset += 4;\n      return value;\n    case 0xcf:\n      hi = this._view.getUint32(this._offset) * Math.pow(2, 32);\n      lo = this._view.getUint32(this._offset + 4);\n      this._offset += 8;\n      return hi + lo;\n\n    // int\n    case 0xd0:\n      value = this._view.getInt8(this._offset);\n      this._offset += 1;\n      return value;\n    case 0xd1:\n      value = this._view.getInt16(this._offset);\n      this._offset += 2;\n      return value;\n    case 0xd2:\n      value = this._view.getInt32(this._offset);\n      this._offset += 4;\n      return value;\n    case 0xd3:\n      hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n      lo = this._view.getUint32(this._offset + 4);\n      this._offset += 8;\n      return hi + lo;\n\n    // fixext\n    case 0xd4:\n      type = this._view.getInt8(this._offset);\n      this._offset += 1;\n      if (type === 0x00) {\n        this._offset += 1;\n        return void 0;\n      }\n      return [type, this._bin(1)];\n    case 0xd5:\n      type = this._view.getInt8(this._offset);\n      this._offset += 1;\n      return [type, this._bin(2)];\n    case 0xd6:\n      type = this._view.getInt8(this._offset);\n      this._offset += 1;\n      return [type, this._bin(4)];\n    case 0xd7:\n      type = this._view.getInt8(this._offset);\n      this._offset += 1;\n      if (type === 0x00) {\n        hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n        lo = this._view.getUint32(this._offset + 4);\n        this._offset += 8;\n        return new Date(hi + lo);\n      }\n      return [type, this._bin(8)];\n    case 0xd8:\n      type = this._view.getInt8(this._offset);\n      this._offset += 1;\n      return [type, this._bin(16)];\n\n    // str\n    case 0xd9:\n      length = this._view.getUint8(this._offset);\n      this._offset += 1;\n      return this._str(length);\n    case 0xda:\n      length = this._view.getUint16(this._offset);\n      this._offset += 2;\n      return this._str(length);\n    case 0xdb:\n      length = this._view.getUint32(this._offset);\n      this._offset += 4;\n      return this._str(length);\n\n    // array\n    case 0xdc:\n      length = this._view.getUint16(this._offset);\n      this._offset += 2;\n      return this._array(length);\n    case 0xdd:\n      length = this._view.getUint32(this._offset);\n      this._offset += 4;\n      return this._array(length);\n\n    // map\n    case 0xde:\n      length = this._view.getUint16(this._offset);\n      this._offset += 2;\n      return this._map(length);\n    case 0xdf:\n      length = this._view.getUint32(this._offset);\n      this._offset += 4;\n      return this._map(length);\n  }\n\n  throw new Error('Could not parse');\n};\n\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder._parse();\n  if (decoder._offset !== buffer.byteLength) {\n    throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');\n  }\n  return value;\n}\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack:///./node_modules/notepack.io/browser/decode.js?");

/***/ }),

/***/ "./node_modules/notepack.io/browser/encode.js":
/*!****************************************************!*\
  !*** ./node_modules/notepack.io/browser/encode.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction utf8Write(view, offset, str) {\n  var c = 0;\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      view.setUint8(offset++, c);\n    }\n    else if (c < 0x800) {\n      view.setUint8(offset++, 0xc0 | (c >> 6));\n      view.setUint8(offset++, 0x80 | (c & 0x3f));\n    }\n    else if (c < 0xd800 || c >= 0xe000) {\n      view.setUint8(offset++, 0xe0 | (c >> 12));\n      view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n      view.setUint8(offset++, 0x80 | (c & 0x3f));\n    }\n    else {\n      i++;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n      view.setUint8(offset++, 0xf0 | (c >> 18));\n      view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);\n      view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n      view.setUint8(offset++, 0x80 | (c & 0x3f));\n    }\n  }\n}\n\nfunction utf8Length(str) {\n  var c = 0, length = 0;\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      length += 1;\n    }\n    else if (c < 0x800) {\n      length += 2;\n    }\n    else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    }\n    else {\n      i++;\n      length += 4;\n    }\n  }\n  return length;\n}\n\nfunction _encode(bytes, defers, value) {\n  var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;\n\n  if (type === 'string') {\n    length = utf8Length(value);\n\n    // fixstr\n    if (length < 0x20) {\n      bytes.push(length | 0xa0);\n      size = 1;\n    }\n    // str 8\n    else if (length < 0x100) {\n      bytes.push(0xd9, length);\n      size = 2;\n    }\n    // str 16\n    else if (length < 0x10000) {\n      bytes.push(0xda, length >> 8, length);\n      size = 3;\n    }\n    // str 32\n    else if (length < 0x100000000) {\n      bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n      size = 5;\n    } else {\n      throw new Error('String too long');\n    }\n    defers.push({ _str: value, _length: length, _offset: bytes.length });\n    return size + length;\n  }\n  if (type === 'number') {\n    // TODO: encode to float 32?\n\n    // float 64\n    if (Math.floor(value) !== value || !isFinite(value)) {\n      bytes.push(0xcb);\n      defers.push({ _float: value, _length: 8, _offset: bytes.length });\n      return 9;\n    }\n\n    if (value >= 0) {\n      // positive fixnum\n      if (value < 0x80) {\n        bytes.push(value);\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        bytes.push(0xcc, value);\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        bytes.push(0xcd, value >> 8, value);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n        return 5;\n      }\n      // uint 64\n      hi = (value / Math.pow(2, 32)) >> 0;\n      lo = value >>> 0;\n      bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 9;\n    } else {\n      // negative fixnum\n      if (value >= -0x20) {\n        bytes.push(value);\n        return 1;\n      }\n      // int 8\n      if (value >= -0x80) {\n        bytes.push(0xd0, value);\n        return 2;\n      }\n      // int 16\n      if (value >= -0x8000) {\n        bytes.push(0xd1, value >> 8, value);\n        return 3;\n      }\n      // int 32\n      if (value >= -0x80000000) {\n        bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n        return 5;\n      }\n      // int 64\n      hi = Math.floor(value / Math.pow(2, 32));\n      lo = value >>> 0;\n      bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 9;\n    }\n  }\n  if (type === 'object') {\n    // nil\n    if (value === null) {\n      bytes.push(0xc0);\n      return 1;\n    }\n\n    if (Array.isArray(value)) {\n      length = value.length;\n\n      // fixarray\n      if (length < 0x10) {\n        bytes.push(length | 0x90);\n        size = 1;\n      }\n      // array 16\n      else if (length < 0x10000) {\n        bytes.push(0xdc, length >> 8, length);\n        size = 3;\n      }\n      // array 32\n      else if (length < 0x100000000) {\n        bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('Array too large');\n      }\n      for (i = 0; i < length; i++) {\n        size += _encode(bytes, defers, value[i]);\n      }\n      return size;\n    }\n\n    // fixext 8 / Date\n    if (value instanceof Date) {\n      var time = value.getTime();\n      hi = Math.floor(time / Math.pow(2, 32));\n      lo = time >>> 0;\n      bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 10;\n    }\n\n    if (value instanceof ArrayBuffer) {\n      length = value.byteLength;\n\n      // bin 8\n      if (length < 0x100) {\n        bytes.push(0xc4, length);\n        size = 2;\n      } else\n      // bin 16\n      if (length < 0x10000) {\n        bytes.push(0xc5, length >> 8, length);\n        size = 3;\n      } else\n      // bin 32\n      if (length < 0x100000000) {\n        bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('Buffer too large');\n      }\n      defers.push({ _bin: value, _length: length, _offset: bytes.length });\n      return size + length;\n    }\n\n    if (typeof value.toJSON === 'function') {\n      return _encode(bytes, defers, value.toJSON());\n    }\n\n    var keys = [], key = '';\n\n    var allKeys = Object.keys(value);\n    for (i = 0, l = allKeys.length; i < l; i++) {\n      key = allKeys[i];\n      if (typeof value[key] !== 'function') {\n        keys.push(key);\n      }\n    }\n    length = keys.length;\n\n    // fixmap\n    if (length < 0x10) {\n      bytes.push(length | 0x80);\n      size = 1;\n    }\n    // map 16\n    else if (length < 0x10000) {\n      bytes.push(0xde, length >> 8, length);\n      size = 3;\n    }\n    // map 32\n    else if (length < 0x100000000) {\n      bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n      size = 5;\n    } else {\n      throw new Error('Object too large');\n    }\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n      size += _encode(bytes, defers, key);\n      size += _encode(bytes, defers, value[key]);\n    }\n    return size;\n  }\n  // false/true\n  if (type === 'boolean') {\n    bytes.push(value ? 0xc3 : 0xc2);\n    return 1;\n  }\n  // fixext 1 / undefined\n  if (type === 'undefined') {\n    bytes.push(0xd4, 0, 0);\n    return 3;\n  }\n  throw new Error('Could not encode');\n}\n\nfunction encode(value) {\n  var bytes = [];\n  var defers = [];\n  var size = _encode(bytes, defers, value);\n  var buf = new ArrayBuffer(size);\n  var view = new DataView(buf);\n\n  var deferIndex = 0;\n  var deferWritten = 0;\n  var nextOffset = -1;\n  if (defers.length > 0) {\n    nextOffset = defers[0]._offset;\n  }\n\n  var defer, deferLength = 0, offset = 0;\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    view.setUint8(deferWritten + i, bytes[i]);\n    if (i + 1 !== nextOffset) { continue; }\n    defer = defers[deferIndex];\n    deferLength = defer._length;\n    offset = deferWritten + nextOffset;\n    if (defer._bin) {\n      var bin = new Uint8Array(defer._bin);\n      for (var j = 0; j < deferLength; j++) {\n        view.setUint8(offset + j, bin[j]);\n      }\n    } else if (defer._str) {\n      utf8Write(view, offset, defer._str);\n    } else if (defer._float !== undefined) {\n      view.setFloat64(offset, defer._float);\n    }\n    deferIndex++;\n    deferWritten += deferLength;\n    if (defers[deferIndex]) {\n      nextOffset = defers[deferIndex]._offset;\n    }\n  }\n  return buf;\n}\n\nmodule.exports = encode;\n\n\n//# sourceURL=webpack:///./node_modules/notepack.io/browser/encode.js?");

/***/ }),

/***/ "./node_modules/notepack.io/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/notepack.io/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.encode = __webpack_require__(/*! ./encode */ \"./node_modules/notepack.io/browser/encode.js\");\nexports.decode = __webpack_require__(/*! ./decode */ \"./node_modules/notepack.io/browser/decode.js\");\n\n\n//# sourceURL=webpack:///./node_modules/notepack.io/lib/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colyseus.js */ \"./node_modules/colyseus.js/lib/index.js\");\n/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(colyseus_js__WEBPACK_IMPORTED_MODULE_0__);\n// import * as PIXI from 'pixi.js';\r\n// import App from './App';\r\n\r\n\r\n\r\n\r\n\r\n//   //Create a Pixi Application\r\n// let pixiApp = new PIXI.Application({width: 256, height: 256});\r\n\r\n// //Add the canvas that Pixi automatically created for you to the HTML document\r\n// document.body.appendChild(pixiApp.view);\r\n\r\n// pixiApp.renderer.backgroundColor = 0xAAAAAA;\r\n// pixiApp.renderer.autoResize = true;\r\n// pixiApp.renderer.resize(7*64, 7*64);\r\n\r\n// PIXI.loader\r\n//   .add([\r\n//     \"./vendor/board.png\",\r\n//     \"./vendor/token_red.png\",\r\n//     \"./vendor/token_yellow.png\"\r\n//   ])\r\n//   .load( () => {\r\n//     // const app = new App(pixiApp);\r\n//     // app.init();\r\n\r\n    \r\n//   });\r\n  \r\nlet client = new colyseus_js__WEBPACK_IMPORTED_MODULE_0__[\"Client\"]('ws://localhost:3000');\r\n\r\nlet room = client.join('game');\r\nroom.onJoin.add( () => {\r\n\r\n  console.log('Joined the room!');\r\n\r\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ 0:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///ws_(ignored)?");

/***/ })

/******/ });